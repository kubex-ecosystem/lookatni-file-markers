<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>cmd: Go Coverage Report</title>
  <style>
    body {
      background: black;
      color: rgb(80, 80, 80);
    }

    body,
    pre,
    #legend span {
      font-family: Menlo, monospace;
      font-weight: bold;
    }

    #topbar {
      background: black;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 42px;
      border-bottom: 1px solid rgb(80, 80, 80);
    }

    #content {
      margin-top: 50px;
    }

    #nav,
    #legend {
      float: left;
      margin-left: 10px;
    }

    #legend {
      margin-top: 12px;
    }

    #nav {
      margin-top: 10px;
    }

    #legend span {
      margin: 0 5px;
    }

    .cov0 {
      color: rgb(192, 0, 0)
    }

    .cov1 {
      color: rgb(128, 128, 128)
    }

    .cov2 {
      color: rgb(116, 140, 131)
    }

    .cov3 {
      color: rgb(104, 152, 134)
    }

    .cov4 {
      color: rgb(92, 164, 137)
    }

    .cov5 {
      color: rgb(80, 176, 140)
    }

    .cov6 {
      color: rgb(68, 188, 143)
    }

    .cov7 {
      color: rgb(56, 200, 146)
    }

    .cov8 {
      color: rgb(44, 212, 149)
    }

    .cov9 {
      color: rgb(32, 224, 152)
    }

    .cov10 {
      color: rgb(20, 236, 155)
    }
  </style>
</head>

<body>
  <div id="topbar">
    <div id="nav">
      <select title="Select a file" id="files">

        <option value="file0">github.com/rafa-mori/lookatni-file-markers/cmd/main.go (0.0%)</option>

        <option value="file1">github.com/rafa-mori/lookatni-file-markers/internal/app/app.go (0.0%)</option>

        <option value="file2">github.com/rafa-mori/lookatni-file-markers/internal/parser/markers.go (0.0%)</option>

        <option value="file3">github.com/rafa-mori/lookatni-file-markers/internal/transpiler/markdown.go (0.0%)</option>

        <option value="file4">github.com/rafa-mori/lookatni-file-markers/internal/vscode/server.go (0.0%)</option>

        <option value="file5">github.com/rafa-mori/lookatni-file-markers/logger/logger.go (0.0%)</option>

        <option value="file6">github.com/rafa-mori/lookatni-file-markers/md_to_html.go (0.0%)</option>

        <option value="file7">github.com/rafa-mori/lookatni-file-markers/version/version.go (0.0%)</option>

      </select>
    </div>
    <div id="legend">
      <span>not tracked</span>

      <span class="cov0">not covered</span>
      <span class="cov8">covered</span>

    </div>
  </div>
  <div id="content">

    <pre class="file" id="file0" style="display: none">// Package main provides the LookAtni File Markers CLI application.
package main

import (
        "flag"
        "fmt"
        "os"

        "github.com/rafa-mori/lookatni-file-markers/internal/app"
        "github.com/rafa-mori/lookatni-file-markers/internal/vscode"
        "github.com/rafa-mori/lookatni-file-markers/logger"
        "github.com/rafa-mori/lookatni-file-markers/version"
)

func main() <span class="cov0" title="0">{
        var (
                versionFlag = flag.Bool("version", false, "Show version information")
                vscodeMode  = flag.Bool("vscode", false, "Run in VS Code integration mode")
                port        = flag.Int("port", 8080, "Port for VS Code integration server")
                verbose     = flag.Bool("v", false, "Enable verbose logging")
        )
        flag.Parse()

        // Initialize logger
        log := logger.New(logger.Config{
                Verbose: *verbose,
                Prefix:  "lookatni",
        })

        if *versionFlag </span><span class="cov0" title="0">{
                fmt.Printf("LookAtni File Markers v%s\n", version.Version)
                fmt.Printf("Build: %s\n", version.BuildHash)
                fmt.Printf("Date: %s\n", version.BuildDate)
                return
        }</span>

        <span class="cov0" title="0">if *vscodeMode </span><span class="cov0" title="0">{
                // Start VS Code integration server
                server := vscode.NewServer(log, *port)
                log.Info("üîå Starting VS Code integration server on port %d", *port)
                if err := server.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to start VS Code server: %v", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Run CLI application
        <span class="cov0" title="0">cliApp := app.New(log)
        if err := cliApp.Run(flag.Args()); err != nil </span><span class="cov0" title="0">{
                log.Error("CLI error: %v", err)
                os.Exit(1)
        }</span>
}
</pre>

    <pre class="file" id="file1" style="display: none">// Package app provides the main CLI application logic for LookAtni File Markers.
package app

import (
        "embed"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/rafa-mori/lookatni-file-markers/internal/parser"
        "github.com/rafa-mori/lookatni-file-markers/internal/transpiler"
        "github.com/rafa-mori/lookatni-file-markers/logger"
)

//go:embed templates/*
var templatesFS embed.FS

// App represents the main CLI application.
type App struct {
        logger     *logger.Logger
        parser     *parser.MarkerParser
        transpiler *transpiler.Transpiler
}

// New creates a new App instance.
func New(log *logger.Logger) *App <span class="cov0" title="0">{
        // Load HTML template
        htmlTemplate, err := templatesFS.ReadFile("templates/base.html")
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to load HTML template: %v", err)
                // Fallback to embedded template
                htmlTemplate = []byte(fallbackHTMLTemplate)
        }</span>

        <span class="cov0" title="0">return &amp;App{
                logger:     log,
                parser:     parser.New(),
                transpiler: transpiler.New(string(htmlTemplate)),
        }</span>
}

// Run executes the CLI application with the given arguments.
func (a *App) Run(args []string) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return a.showHelp()
        }</span>

        <span class="cov0" title="0">command := args[0]
        switch command </span>{
        case "extract":<span class="cov0" title="0">
                return a.extractCommand(args[1:])</span>
        case "validate":<span class="cov0" title="0">
                return a.validateCommand(args[1:])</span>
        case "transpile":<span class="cov0" title="0">
                return a.transpileCommand(args[1:])</span>
        case "generate":<span class="cov0" title="0">
                return a.generateCommand(args[1:])</span>
        case "help":<span class="cov0" title="0">
                return a.showHelp()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown command: %s", command)</span>
        }
}

// extractCommand handles file extraction from marked files.
func (a *App) extractCommand(args []string) error <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("usage: extract &lt;marked-file&gt; &lt;output-dir&gt; [--overwrite] [--create-dirs] [--dry-run]")
        }</span>

        <span class="cov0" title="0">markedFile := args[0]
        outputDir := args[1]

        options := parser.ExtractOptions{
                Overwrite:  false,
                CreateDirs: true,
                DryRun:     false,
        }

        // Parse flags
        for _, arg := range args[2:] </span><span class="cov0" title="0">{
                switch arg </span>{
                case "--overwrite":<span class="cov0" title="0">
                        options.Overwrite = true</span>
                case "--create-dirs":<span class="cov0" title="0">
                        options.CreateDirs = true</span>
                case "--dry-run":<span class="cov0" title="0">
                        options.DryRun = true</span>
                }
        }

        <span class="cov0" title="0">a.logger.Info("üîÑ Extracting files from %s to %s", markedFile, outputDir)

        result, err := a.parser.ExtractFiles(markedFile, outputDir, options)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("extraction failed: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                a.logger.Warn("‚ö†Ô∏è  Extraction completed with errors:")
                for _, errMsg := range result.Errors </span><span class="cov0" title="0">{
                        a.logger.Warn("   %s", errMsg)
                }</span>
        }

        <span class="cov0" title="0">if options.DryRun </span><span class="cov0" title="0">{
                a.logger.Info("üîç [DRY RUN] Would extract %d files", len(result.ExtractedFiles))
        }</span> else<span class="cov0" title="0"> {
                a.logger.Info("‚úÖ Successfully extracted %d files", len(result.ExtractedFiles))
        }</span>

        <span class="cov0" title="0">for _, file := range result.ExtractedFiles </span><span class="cov0" title="0">{
                if options.DryRun </span><span class="cov0" title="0">{
                        a.logger.Debug("   [DRY RUN] %s", file)
                }</span> else<span class="cov0" title="0"> {
                        a.logger.Debug("   ‚úì %s", file)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateCommand handles marker validation.
func (a *App) validateCommand(args []string) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("usage: validate &lt;marked-file&gt;")
        }</span>

        <span class="cov0" title="0">markedFile := args[0]
        a.logger.Info("üîç Validating markers in %s", markedFile)

        result, err := a.parser.ValidateMarkers(markedFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if result.IsValid </span><span class="cov0" title="0">{
                a.logger.Info("‚úÖ All markers are valid!")
        }</span> else<span class="cov0" title="0"> {
                a.logger.Warn("‚ö†Ô∏è  Validation issues found:")
        }</span>

        <span class="cov0" title="0">if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                a.logger.Warn("Errors:")
                for _, errMsg := range result.Errors </span><span class="cov0" title="0">{
                        a.logger.Warn("   Line %d: %s (%s)", errMsg.Line, errMsg.Message, errMsg.Severity)
                }</span>
        }

        <span class="cov0" title="0">if len(result.DuplicateFilenames) &gt; 0 </span><span class="cov0" title="0">{
                a.logger.Warn("Duplicate filenames:")
                for _, dup := range result.DuplicateFilenames </span><span class="cov0" title="0">{
                        a.logger.Warn("   %s", dup)
                }</span>
        }

        <span class="cov0" title="0">if len(result.InvalidFilenames) &gt; 0 </span><span class="cov0" title="0">{
                a.logger.Warn("Invalid filenames:")
                for _, invalid := range result.InvalidFilenames </span><span class="cov0" title="0">{
                        a.logger.Warn("   %s", invalid)
                }</span>
        }

        <span class="cov0" title="0">stats := result.Statistics
        a.logger.Info("üìä Statistics:")
        a.logger.Info("   Total markers: %d", stats.TotalMarkers)
        a.logger.Info("   Empty markers: %d", stats.EmptyMarkers)

        return nil</span>
}

// transpileCommand handles Markdown to HTML transpilation.
func (a *App) transpileCommand(args []string) error <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("usage: transpile &lt;input-dir|file&gt; &lt;output-dir&gt;")
        }</span>

        <span class="cov0" title="0">input := args[0]
        outputDir := args[1]

        a.logger.Info("üîÑ Transpiling from %s to %s", input, outputDir)

        stat, err := os.Stat(input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("input not found: %w", err)
        }</span>

        <span class="cov0" title="0">var files []transpiler.FileInfo
        var totalSize int64

        if stat.IsDir() </span><span class="cov0" title="0">{
                // Process directory
                entries, err := os.ReadDir(input)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read directory: %w", err)
                }</span>

                <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                        if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".md") </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if !strings.HasPrefix(entry.Name(), "interview_") </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">filePath := filepath.Join(input, entry.Name())
                        content, err := os.ReadFile(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                a.logger.Warn("Failed to read %s: %v", filePath, err)
                                continue</span>
                        }

                        <span class="cov0" title="0">fileInfo, err := a.transpiler.ConvertMarkdownToHTML(entry.Name(), content, outputDir)
                        if err != nil </span><span class="cov0" title="0">{
                                a.logger.Warn("Failed to transpile %s: %v", entry.Name(), err)
                                continue</span>
                        }

                        <span class="cov0" title="0">files = append(files, *fileInfo)

                        // Calculate size
                        if stat, err := os.Stat(filepath.Join(outputDir, fileInfo.FileName)); err == nil </span><span class="cov0" title="0">{
                                totalSize += stat.Size()
                        }</span>

                        <span class="cov0" title="0">a.logger.Debug("   ‚úì %s -&gt; %s", entry.Name(), fileInfo.FileName)</span>
                }
        } else<span class="cov0" title="0"> {
                // Process single file
                if !strings.HasSuffix(input, ".md") </span><span class="cov0" title="0">{
                        return fmt.Errorf("input must be a .md file")
                }</span>

                <span class="cov0" title="0">content, err := os.ReadFile(input)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read file: %w", err)
                }</span>

                <span class="cov0" title="0">filename := filepath.Base(input)
                fileInfo, err := a.transpiler.ConvertMarkdownToHTML(filename, content, outputDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("transpilation failed: %w", err)
                }</span>

                <span class="cov0" title="0">files = append(files, *fileInfo)
                if stat, err := os.Stat(filepath.Join(outputDir, fileInfo.FileName)); err == nil </span><span class="cov0" title="0">{
                        totalSize = stat.Size()
                }</span>
        }

        // Generate index
        <span class="cov0" title="0">if len(files) &gt; 0 </span><span class="cov0" title="0">{
                if err := a.transpiler.GenerateIndex(files, totalSize, outputDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate index: %w", err)
                }</span>
                <span class="cov0" title="0">a.logger.Info("‚úÖ Generated index with %d files", len(files))</span>
        }

        <span class="cov0" title="0">a.logger.Info("‚úÖ Transpilation completed: %d files processed", len(files))
        return nil</span>
}

// generateCommand handles marker generation (placeholder for future implementation).
func (a *App) generateCommand(args []string) error <span class="cov0" title="0">{
        a.logger.Info("üöß Generate command not yet implemented")
        return nil
}</span>

// showHelp displays help information.
func (a *App) showHelp() error <span class="cov0" title="0">{
        help := `LookAtni File Markers v2.0 - Advanced file organization with Go power

Usage:
  lookatni &lt;command&gt; [options]

Commands:
  extract &lt;marked-file&gt; &lt;output-dir&gt; [flags]  Extract files from marked content
  validate &lt;marked-file&gt;                      Validate markers in file
  transpile &lt;input&gt; &lt;output-dir&gt;              Convert Markdown to HTML
  generate                                    Generate markers (coming soon)
  help                                        Show this help

Extract Flags:
  --overwrite     Overwrite existing files
  --create-dirs   Create directories as needed
  --dry-run       Show what would be done without doing it

Examples:
  lookatni extract marked_content.txt ./output --overwrite --create-dirs
  lookatni validate my_project.md
  lookatni transpile ./interviews ./output

For VS Code integration, run with --vscode flag.
`
        fmt.Print(help)
        return nil
}</span>

// fallbackHTMLTemplate is used when the embedded template fails to load.
const fallbackHTMLTemplate = `&lt;!doctype html&gt;
&lt;html lang="pt-BR"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
    &lt;title&gt;Interview Prep&lt;/title&gt;
    &lt;style&gt;
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; line-height: 1.6; }
      pre, code { background: #f6f8fa; padding: .2rem .4rem; border-radius: 4px; }
      a { color: #0b69c7; text-decoration: none; }
      a:hover { text-decoration: underline; }
      h1, h2, h3 { line-height: 1.25; }
      .container { max-width: 900px; margin: 0 auto; }
      kx-prompt-block { display: block; border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px; margin: 16px 0; }
      .kx-field { margin: 8px 0; }
      .kx-controls { display: flex; gap: 8px; margin-top: 8px; }
      .kx-controls button { background: #0b69c7; color: white; border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; }
      .kx-controls button.secondary { background: #6b7280; }
      .kx-controls button:hover { opacity: .95; }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class="container"&gt;
      {{.Content}}
    &lt;/div&gt;
    &lt;script&gt;
      // Add interactive functionality for prompt blocks
      document.addEventListener('DOMContentLoaded', function() {
        const promptBlocks = document.querySelectorAll('kx-prompt-block');
        promptBlocks.forEach(block =&gt; {
          const runButton = block.querySelector('button.run');
          if (runButton) {
            runButton.addEventListener('click', function() {
              console.log('Run with MCP clicked');
              // TODO: Implement MCP integration
            });
          }
        });
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;`
</pre>

    <pre class="file" id="file2" style="display: none">// Package parser provides marker parsing functionality for LookAtni File Markers.
package parser

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "regexp"
        "strings"
)

// ParsedMarker represents a single file marker found in source.
type ParsedMarker struct {
        Filename  string `json:"filename"`
        Content   string `json:"content"`
        StartLine int    `json:"startLine"`
        EndLine   int    `json:"endLine"`
        Size      int64  `json:"size"`
}

// ParseResults contains the results of parsing a marked file.
type ParseResults struct {
        TotalMarkers int            `json:"totalMarkers"`
        TotalFiles   int            `json:"totalFiles"`
        TotalBytes   int64          `json:"totalBytes"`
        Errors       []ParseError   `json:"errors"`
        Markers      []ParsedMarker `json:"markers"`
}

// ParseError represents an error found during parsing.
type ParseError struct {
        Line     int    `json:"line"`
        Message  string `json:"message"`
        Severity string `json:"severity"` // "error", "warning"
}

// ExtractOptions defines options for file extraction.
type ExtractOptions struct {
        Overwrite  bool `json:"overwrite"`
        CreateDirs bool `json:"createDirs"`
        DryRun     bool `json:"dryRun"`
}

// ExtractResults contains the results of file extraction.
type ExtractResults struct {
        Success        bool     `json:"success"`
        ExtractedFiles []string `json:"extractedFiles"`
        Errors         []string `json:"errors"`
}

// MarkerParser handles parsing and extraction of file markers.
type MarkerParser struct {
        // ASCII 28 (File Separator) character for invisible markers
        fsChar      string
        markerRegex *regexp.Regexp
}

// New creates a new MarkerParser instance.
func New() *MarkerParser <span class="cov0" title="0">{
        fsChar := string(rune(28)) // ASCII 28 File Separator

        // Create regex pattern: //FS/ filename /FS//
        pattern := fmt.Sprintf(`^\/\/%s\/ (.+?) \/%s\/\/$`, regexp.QuoteMeta(fsChar), regexp.QuoteMeta(fsChar))
        markerRegex := regexp.MustCompile(pattern)

        return &amp;MarkerParser{
                fsChar:      fsChar,
                markerRegex: markerRegex,
        }
}</span>

// ParseMarkedFile parses a file containing LookAtni markers.
func (mp *MarkerParser) ParseMarkedFile(filePath string) (*ParseResults, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open file %s: %w", filePath, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return mp.ParseMarkedReader(file, filePath)</span>
}

// ParseMarkedReader parses markers from a reader.
func (mp *MarkerParser) ParseMarkedReader(reader io.Reader, sourceName string) (*ParseResults, error) <span class="cov0" title="0">{
        results := &amp;ParseResults{
                Errors:  make([]ParseError, 0),
                Markers: make([]ParsedMarker, 0),
        }

        scanner := bufio.NewScanner(reader)
        lineNumber := 0

        var currentMarker *ParsedMarker
        var currentContent strings.Builder

        for scanner.Scan() </span><span class="cov0" title="0">{
                lineNumber++
                line := scanner.Text()

                // Check if this line is a marker
                if match := mp.markerRegex.FindStringSubmatch(line); match != nil </span><span class="cov0" title="0">{
                        // Save previous marker if exists
                        if currentMarker != nil </span><span class="cov0" title="0">{
                                mp.finalizeMarker(currentMarker, &amp;currentContent, results, lineNumber-1)
                        }</span>

                        // Start new marker
                        <span class="cov0" title="0">filename := strings.TrimSpace(match[1])
                        if filename == "" </span><span class="cov0" title="0">{
                                results.Errors = append(results.Errors, ParseError{
                                        Line:     lineNumber,
                                        Message:  "Empty filename in marker",
                                        Severity: "error",
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">currentMarker = &amp;ParsedMarker{
                                Filename:  filename,
                                StartLine: lineNumber,
                        }
                        currentContent.Reset()
                        results.TotalMarkers++</span>

                } else<span class="cov0" title="0"> if currentMarker != nil </span><span class="cov0" title="0">{
                        // Add content to current marker
                        if currentContent.Len() &gt; 0 </span><span class="cov0" title="0">{
                                currentContent.WriteByte('\n')
                        }</span>
                        <span class="cov0" title="0">currentContent.WriteString(line)</span>
                }
        }

        // Finalize last marker
        <span class="cov0" title="0">if currentMarker != nil </span><span class="cov0" title="0">{
                mp.finalizeMarker(currentMarker, &amp;currentContent, results, lineNumber)
        }</span>

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading %s: %w", sourceName, err)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// finalizeMarker completes a marker and adds it to results.
func (mp *MarkerParser) finalizeMarker(marker *ParsedMarker, content *strings.Builder, results *ParseResults, endLine int) <span class="cov0" title="0">{
        // Remove trailing empty lines
        finalContent := strings.TrimRight(content.String(), "\n")

        marker.Content = finalContent
        marker.EndLine = endLine
        marker.Size = int64(len(finalContent))

        results.Markers = append(results.Markers, *marker)
        results.TotalFiles++
        results.TotalBytes += marker.Size
}</span>

// ExtractFiles extracts all markers to files in the specified directory.
func (mp *MarkerParser) ExtractFiles(markedFilePath, outputDir string, options ExtractOptions) (*ExtractResults, error) <span class="cov0" title="0">{
        result := &amp;ExtractResults{
                Success:        true,
                ExtractedFiles: make([]string, 0),
                Errors:         make([]string, 0),
        }

        parseResults, err := mp.ParseMarkedFile(markedFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse marked file: %w", err)
        }</span>

        // Add parse errors to result
        <span class="cov0" title="0">for _, parseErr := range parseResults.Errors </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, fmt.Sprintf("Line %d: %s", parseErr.Line, parseErr.Message))
        }</span>

        <span class="cov0" title="0">for _, marker := range parseResults.Markers </span><span class="cov0" title="0">{
                outputPath := filepath.Join(outputDir, marker.Filename)

                // Check if file exists and overwrite is disabled
                if !options.Overwrite </span><span class="cov0" title="0">{
                        if _, err := os.Stat(outputPath); err == nil </span><span class="cov0" title="0">{
                                if options.DryRun </span><span class="cov0" title="0">{
                                        result.Errors = append(result.Errors, fmt.Sprintf("Would skip existing file: %s", outputPath))
                                }</span> else<span class="cov0" title="0"> {
                                        result.Errors = append(result.Errors, fmt.Sprintf("File exists (use --overwrite): %s", outputPath))
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                }

                <span class="cov0" title="0">if options.DryRun </span><span class="cov0" title="0">{
                        result.ExtractedFiles = append(result.ExtractedFiles, outputPath)
                        continue</span>
                }

                // Create directory if needed
                <span class="cov0" title="0">if options.CreateDirs </span><span class="cov0" title="0">{
                        dir := filepath.Dir(outputPath)
                        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                                result.Errors = append(result.Errors, fmt.Sprintf("Failed to create directory %s: %v", dir, err))
                                result.Success = false
                                continue</span>
                        }
                }

                // Write file
                <span class="cov0" title="0">if err := os.WriteFile(outputPath, []byte(marker.Content), 0644); err != nil </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to write %s: %v", outputPath, err))
                        result.Success = false
                        continue</span>
                }

                <span class="cov0" title="0">result.ExtractedFiles = append(result.ExtractedFiles, outputPath)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// ValidateMarkers validates markers in a file and returns detailed information.
func (mp *MarkerParser) ValidateMarkers(filePath string) (*ValidationResults, error) <span class="cov0" title="0">{
        parseResults, err := mp.ParseMarkedFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">validation := &amp;ValidationResults{
                IsValid:            len(parseResults.Errors) == 0,
                Errors:             make([]ValidationError, 0),
                DuplicateFilenames: make([]string, 0),
                InvalidFilenames:   make([]string, 0),
                Statistics: ValidationStatistics{
                        TotalMarkers: parseResults.TotalMarkers,
                        EmptyMarkers: 0,
                },
        }

        // Convert parse errors
        for _, parseErr := range parseResults.Errors </span><span class="cov0" title="0">{
                validation.Errors = append(validation.Errors, ValidationError(parseErr))
        }</span>

        // Check for duplicates and validation issues
        <span class="cov0" title="0">filenameCount := make(map[string]int)
        for _, marker := range parseResults.Markers </span><span class="cov0" title="0">{
                filenameCount[marker.Filename]++

                // Check for empty markers
                if strings.TrimSpace(marker.Content) == "" </span><span class="cov0" title="0">{
                        validation.Statistics.EmptyMarkers++
                }</span>

                // Validate filename
                <span class="cov0" title="0">if !mp.isValidFilename(marker.Filename) </span><span class="cov0" title="0">{
                        validation.InvalidFilenames = append(validation.InvalidFilenames, marker.Filename)
                }</span>
        }

        // Find duplicates
        <span class="cov0" title="0">for filename, count := range filenameCount </span><span class="cov0" title="0">{
                if count &gt; 1 </span><span class="cov0" title="0">{
                        validation.DuplicateFilenames = append(validation.DuplicateFilenames, filename)
                }</span>
        }

        // Update validity
        <span class="cov0" title="0">if len(validation.DuplicateFilenames) &gt; 0 || len(validation.InvalidFilenames) &gt; 0 || validation.Statistics.EmptyMarkers &gt; 0 </span><span class="cov0" title="0">{
                validation.IsValid = false
        }</span>

        <span class="cov0" title="0">return validation, nil</span>
}

// ValidationResults contains marker validation results.
type ValidationResults struct {
        IsValid            bool                 `json:"isValid"`
        Errors             []ValidationError    `json:"errors"`
        DuplicateFilenames []string             `json:"duplicateFilenames"`
        InvalidFilenames   []string             `json:"invalidFilenames"`
        Statistics         ValidationStatistics `json:"statistics"`
}

// ValidationError represents a validation error.
type ValidationError struct {
        Line     int    `json:"line"`
        Message  string `json:"message"`
        Severity string `json:"severity"`
}

// ValidationStatistics contains validation statistics.
type ValidationStatistics struct {
        TotalMarkers int `json:"totalMarkers"`
        EmptyMarkers int `json:"emptyMarkers"`
}

// isValidFilename checks if a filename is valid for the current OS.
func (mp *MarkerParser) isValidFilename(filename string) bool <span class="cov0" title="0">{
        if filename == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for invalid characters (basic check)
        <span class="cov0" title="0">invalidChars := []string{"&lt;", "&gt;", ":", "\"", "|", "?", "*"}
        for _, char := range invalidChars </span><span class="cov0" title="0">{
                if strings.Contains(filename, char) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check for reserved names (Windows)
        <span class="cov0" title="0">reserved := []string{"CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"}
        upper := strings.ToUpper(filename)
        for _, res := range reserved </span><span class="cov0" title="0">{
                if upper == res || strings.HasPrefix(upper, res+".") </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}
</pre>

    <pre class="file" id="file3" style="display: none">// Package transpiler provides Markdown to HTML transpilation with prompt block support.
package transpiler

import (
        "encoding/json"
        "fmt"
        htmlpkg "html"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/gomarkdown/markdown"
        "github.com/gomarkdown/markdown/ast"
        "github.com/gomarkdown/markdown/html"
        "github.com/gomarkdown/markdown/parser"
        "gopkg.in/yaml.v3"
)

// Frontmatter represents YAML frontmatter in Markdown files.
type Frontmatter struct {
        Title    interface{}            `yaml:"title"`
        Tags     []string               `yaml:"tags"`
        Context  map[string]interface{} `yaml:"context"`
        Defaults struct {
                Model       string   `yaml:"model"`
                Temperature float64  `yaml:"temperature"`
                ToolHints   []string `yaml:"toolHints"`
        } `yaml:"defaults"`
}

// PromptInput represents an input field in a prompt block.
type PromptInput struct {
        Name   string   `yaml:"name"`
        Type   string   `yaml:"type"`
        Values []string `yaml:"values"`
}

// PromptBody represents the YAML content of a prompt block.
type PromptBody struct {
        Role     string        `yaml:"role"`
        Goal     string        `yaml:"goal"`
        Inputs   []PromptInput `yaml:"inputs"`
        Template string        `yaml:"template"`
}

// PromptAttrs represents attributes from the prompt fence line.
type PromptAttrs struct {
        ID        string
        Mode      string
        ToolHints []string
}

// FileInfo represents information about a generated HTML file.
type FileInfo struct {
        FileName    string `json:"fileName"`
        Title       string `json:"title"`
        Description string `json:"description"`
        Size        string `json:"size"`
        Icon        string `json:"icon"`
}

// Transpiler handles Markdown to HTML conversion with prompt blocks.
type Transpiler struct {
        // Compiled regex patterns
        fmRegex     *regexp.Regexp
        fenceRegex  *regexp.Regexp
        attrKVRegex *regexp.Regexp
        quoteTrim   *regexp.Regexp
        bracketTrim *regexp.Regexp
        listSplit   *regexp.Regexp

        // HTML template
        htmlTemplate string
}

// New creates a new Transpiler instance.
func New(htmlTemplate string) *Transpiler <span class="cov0" title="0">{
        return &amp;Transpiler{
                fmRegex:      regexp.MustCompile(`(?s)^---\n(.*?)\n---\n`),
                fenceRegex:   regexp.MustCompile("(?s)```prompt\\s*([^\\n]*)\\n(.*?)```\\s*"),
                attrKVRegex:  regexp.MustCompile(`(\w+)=([^\s]+)`),
                quoteTrim:    regexp.MustCompile(`^\"|\"$`),
                bracketTrim:  regexp.MustCompile(`^[\[]|[\]]$`),
                listSplit:    regexp.MustCompile(`\s*,\s*`),
                htmlTemplate: htmlTemplate,
        }
}</span>

// ConvertMarkdownToHTML converts a Markdown file to HTML with prompt block processing.
func (t *Transpiler) ConvertMarkdownToHTML(filename string, content []byte, outputDir string) (*FileInfo, error) <span class="cov0" title="0">{
        // Preprocess markdown (frontmatter + prompt blocks)
        processed, frontmatter, blockCount := t.preprocessMarkdown(string(content))

        // Generate HTML file path
        baseName := strings.TrimSuffix(strings.TrimPrefix(filename, "interview_"), ".md")
        htmlFileName := fmt.Sprintf("%s_view.html", baseName)
        htmlFilePath := filepath.Join(outputDir, htmlFileName)

        // Ensure output directory exists
        if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        // Convert markdown to HTML
        <span class="cov0" title="0">extensions := parser.CommonExtensions | parser.AutoHeadingIDs
        p := parser.NewWithExtensions(extensions)
        doc := p.Parse([]byte(processed))

        htmlFlags := html.CommonFlags | html.HrefTargetBlank
        opts := html.RendererOptions{Flags: htmlFlags}
        renderer := html.NewRenderer(opts)

        htmlContent := markdown.Render(doc, renderer)

        // Apply HTML template
        finalHTML := strings.ReplaceAll(t.htmlTemplate, "{{.Content}}", string(htmlContent))

        // Write HTML file
        if err := os.WriteFile(htmlFilePath, []byte(finalHTML), 0644); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write HTML file: %w", err)
        }</span>

        // Generate supplementary files
        <span class="cov0" title="0">if err := t.writeTocJSON(doc, outputDir, htmlFilePath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write TOC JSON: %w", err)
        }</span>

        <span class="cov0" title="0">if err := t.writeDocIndexJSON(outputDir, htmlFilePath, filename, doc, blockCount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write doc index JSON: %w", err)
        }</span>

        // Calculate file size
        <span class="cov0" title="0">stat, err := os.Stat(htmlFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat HTML file: %w", err)
        }</span>

        <span class="cov0" title="0">fileInfo := &amp;FileInfo{
                FileName:    htmlFileName,
                Title:       t.generateTitle(filename),
                Description: t.generateDescription(frontmatter),
                Size:        fmt.Sprintf("%.1f", float64(stat.Size())/1024),
                Icon:        t.generateIcon(filename),
        }

        return fileInfo, nil</span>
}

// preprocessMarkdown parses frontmatter and transpiles prompt blocks.
func (t *Transpiler) preprocessMarkdown(src string) (string, *Frontmatter, int) <span class="cov0" title="0">{
        var fm *Frontmatter

        // Extract frontmatter if present
        if m := t.fmRegex.FindStringSubmatch(src); len(m) == 2 </span><span class="cov0" title="0">{
                fm = &amp;Frontmatter{}
                if err := yaml.Unmarshal([]byte(m[1]), fm); err != nil </span><span class="cov0" title="0">{
                        // Ignore FM errors; proceed without FM
                        fm = nil
                }</span>
                <span class="cov0" title="0">src = src[len(m[0]):]</span>
        }

        <span class="cov0" title="0">replaced := 0
        out := t.fenceRegex.ReplaceAllStringFunc(src, func(full string) string </span><span class="cov0" title="0">{
                m := t.fenceRegex.FindStringSubmatch(full)
                if len(m) != 3 </span><span class="cov0" title="0">{
                        return full
                }</span>

                <span class="cov0" title="0">attrLine := strings.TrimSpace(m[1])
                bodyYAML := strings.TrimSpace(m[2])

                attrs := t.parsePromptAttrs(attrLine)
                var pb PromptBody
                if err := yaml.Unmarshal([]byte(bodyYAML), &amp;pb); err != nil </span><span class="cov0" title="0">{
                        // leave original block if YAML fails
                        return full
                }</span>

                // Merge defaults from frontmatter and block
                <span class="cov0" title="0">defaults := make(map[string]interface{})
                if fm != nil </span><span class="cov0" title="0">{
                        if fm.Defaults.Model != "" </span><span class="cov0" title="0">{
                                defaults["model"] = fm.Defaults.Model
                        }</span>
                        <span class="cov0" title="0">if fm.Defaults.Temperature != 0 </span><span class="cov0" title="0">{
                                defaults["temperature"] = fm.Defaults.Temperature
                        }</span>
                        <span class="cov0" title="0">if len(fm.Defaults.ToolHints) &gt; 0 </span><span class="cov0" title="0">{
                                defaults["toolHints"] = fm.Defaults.ToolHints
                        }</span>
                }
                <span class="cov0" title="0">if pb.Role != "" </span><span class="cov0" title="0">{
                        defaults["role"] = pb.Role
                }</span>
                <span class="cov0" title="0">if pb.Goal != "" </span><span class="cov0" title="0">{
                        defaults["goal"] = pb.Goal
                }</span>
                <span class="cov0" title="0">if attrs.Mode != "" </span><span class="cov0" title="0">{
                        defaults["mode"] = attrs.Mode
                }</span>
                <span class="cov0" title="0">if len(attrs.ToolHints) &gt; 0 </span><span class="cov0" title="0">{
                        defaults["toolHints"] = attrs.ToolHints
                }</span>

                <span class="cov0" title="0">defJSON, _ := json.Marshal(defaults)
                templateAttr := htmlpkg.EscapeString(pb.Template)

                // Build inputs HTML
                var fields []string
                for _, in := range pb.Inputs </span><span class="cov0" title="0">{
                        valuesJSON, _ := json.Marshal(in.Values)
                        fields = append(fields, fmt.Sprintf(
                                `&lt;kx-field name="%s" type="%s" values='%s'&gt;&lt;/kx-field&gt;`,
                                htmlpkg.EscapeString(in.Name), htmlpkg.EscapeString(in.Type), htmlpkg.EscapeString(string(valuesJSON)),
                        ))
                }</span>
                <span class="cov0" title="0">inner := strings.Join(fields, "\n  ") + "\n  &lt;button class=\"run\"&gt;Run with MCP&lt;/button&gt;\n  &lt;pre class=\"preview\"&gt;&lt;/pre&gt;"

                htmlBlock := fmt.Sprintf(
                        `&lt;kx-prompt-block data-id="%s" data-defaults='%s' data-template="%s"&gt;
  %s
&lt;/kx-prompt-block&gt;`,
                        htmlpkg.EscapeString(attrs.ID), htmlpkg.EscapeString(string(defJSON)), templateAttr, inner,
                )

                replaced++
                return htmlBlock</span>
        })

        <span class="cov0" title="0">return out, fm, replaced</span>
}

// parsePromptAttrs parses attributes from the prompt fence line.
func (t *Transpiler) parsePromptAttrs(line string) PromptAttrs <span class="cov0" title="0">{
        pa := PromptAttrs{}
        for _, m := range t.attrKVRegex.FindAllStringSubmatch(line, -1) </span><span class="cov0" title="0">{
                if len(m) != 3 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">key := m[1]
                val := m[2]

                // Unwrap quotes or brackets
                if strings.HasPrefix(val, "\"") &amp;&amp; strings.HasSuffix(val, "\"") </span><span class="cov0" title="0">{
                        val = t.quoteTrim.ReplaceAllString(val, "")
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(val, "[") &amp;&amp; strings.HasSuffix(val, "]") </span><span class="cov0" title="0">{
                        raw := t.bracketTrim.ReplaceAllString(val, "")
                        items := []string{}
                        for _, it := range t.listSplit.Split(raw, -1) </span><span class="cov0" title="0">{
                                it = strings.TrimSpace(it)
                                it = t.quoteTrim.ReplaceAllString(it, "")
                                if it != "" </span><span class="cov0" title="0">{
                                        items = append(items, it)
                                }</span>
                        }
                        <span class="cov0" title="0">if key == "toolHints" </span><span class="cov0" title="0">{
                                pa.ToolHints = items
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">switch key </span>{
                case "id":<span class="cov0" title="0">
                        pa.ID = val</span>
                case "mode":<span class="cov0" title="0">
                        pa.Mode = val</span>
                case "toolHints":<span class="cov0" title="0">
                        // already handled above if bracket form
                        if val != "" </span><span class="cov0" title="0">{
                                pa.ToolHints = append(pa.ToolHints, val)
                        }</span>
                }
        }
        <span class="cov0" title="0">return pa</span>
}

// writeTocJSON generates a table of contents JSON file.
func (t *Transpiler) writeTocJSON(doc ast.Node, outDir, htmlPath string) error <span class="cov0" title="0">{
        type tocItem struct {
                Level int    `json:"level"`
                Text  string `json:"text"`
                ID    string `json:"id"`
        }

        var items []tocItem
        ast.WalkFunc(doc, func(n ast.Node, entering bool) ast.WalkStatus </span><span class="cov0" title="0">{
                if !entering </span><span class="cov0" title="0">{
                        return ast.GoToNext
                }</span>
                <span class="cov0" title="0">if h, ok := n.(*ast.Heading); ok </span><span class="cov0" title="0">{
                        // gather text
                        var b strings.Builder
                        for _, c := range n.GetChildren() </span><span class="cov0" title="0">{
                                if t, ok := c.(*ast.Text); ok </span><span class="cov0" title="0">{
                                        b.Write(t.Literal)
                                }</span>
                        }
                        <span class="cov0" title="0">text := b.String()
                        id := t.slugify(text)
                        items = append(items, tocItem{Level: h.Level, Text: text, ID: id})</span>
                }
                <span class="cov0" title="0">return ast.GoToNext</span>
        })

        <span class="cov0" title="0">data, _ := json.MarshalIndent(items, "", "  ")
        base := strings.TrimSuffix(filepath.Base(htmlPath), filepath.Ext(htmlPath))
        return os.WriteFile(filepath.Join(outDir, base+"_toc.json"), data, 0644)</span>
}

// writeDocIndexJSON writes document metadata JSON.
func (t *Transpiler) writeDocIndexJSON(outDir, htmlPath, srcName string, doc ast.Node, blockCount int) error <span class="cov0" title="0">{
        idx := map[string]interface{}{
                "source":      srcName,
                "title":       t.generateTitle(srcName),
                "blocks":      blockCount,
                "generatedAt": time.Now().Format(time.RFC3339),
        }

        data, _ := json.MarshalIndent(idx, "", "  ")
        base := strings.TrimSuffix(filepath.Base(htmlPath), filepath.Ext(htmlPath))
        return os.WriteFile(filepath.Join(outDir, base+"_index.json"), data, 0644)
}</span>

// generateTitle creates a human-readable title from filename.
func (t *Transpiler) generateTitle(filename string) string <span class="cov0" title="0">{
        name := strings.TrimSuffix(strings.TrimPrefix(filename, "interview_"), ".md")
        name = strings.ReplaceAll(name, "_", " ")

        // Capitalize first letter of each word
        words := strings.Fields(name)
        for i, word := range words </span><span class="cov0" title="0">{
                if len(word) &gt; 0 </span><span class="cov0" title="0">{
                        words[i] = strings.ToUpper(word[:1]) + word[1:]
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(words, " ")</span>
}

// generateDescription creates a description from frontmatter or filename.
func (t *Transpiler) generateDescription(fm *Frontmatter) string <span class="cov0" title="0">{
        if fm != nil &amp;&amp; fm.Title != nil </span><span class="cov0" title="0">{
                if title, ok := fm.Title.(string); ok </span><span class="cov0" title="0">{
                        return title
                }</span>
        }
        <span class="cov0" title="0">return "Documento de prepara√ß√£o para entrevista t√©cnica."</span>
}

// generateIcon returns an appropriate icon for the file type.
func (t *Transpiler) generateIcon(filename string) string <span class="cov0" title="0">{
        if strings.Contains(filename, "test") </span><span class="cov0" title="0">{
                return "üß™"
        }</span>
        <span class="cov0" title="0">if strings.Contains(filename, "v2") || strings.Contains(filename, "refined") </span><span class="cov0" title="0">{
                return "üîÑ"
        }</span>
        <span class="cov0" title="0">return "üìã"</span>
}

// slugify converts text to URL-friendly slug.
func (t *Transpiler) slugify(s string) string <span class="cov0" title="0">{
        s = strings.ToLower(s)
        var b strings.Builder
        dash := false

        for _, r := range s </span><span class="cov0" title="0">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == ' ' || r == '-' </span><span class="cov0" title="0">{
                        if r == ' ' </span><span class="cov0" title="0">{
                                r = '-'
                        }</span>
                        <span class="cov0" title="0">if r == '-' </span><span class="cov0" title="0">{
                                if dash </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">dash = true</span>
                        } else<span class="cov0" title="0"> {
                                dash = false
                        }</span>
                        <span class="cov0" title="0">b.WriteRune(r)</span>
                }
        }

        <span class="cov0" title="0">out := b.String()
        out = strings.Trim(out, "-")
        return out</span>
}

// GenerateIndex creates an index.html and index.json for multiple files.
func (t *Transpiler) GenerateIndex(files []FileInfo, totalSizeBytes int64, outputDir string) error <span class="cov0" title="0">{
        // Generate index.html
        indexTemplate := `&lt;!doctype html&gt;
&lt;html lang="pt-BR"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
    &lt;title&gt;Interview Index&lt;/title&gt;
    &lt;style&gt;
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; line-height: 1.6; }
      .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 16px; }
      .card { border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; }
      .title { font-size: 1.1rem; margin: 0 0 8px; }
      .meta { color: #6b7280; font-size: .9rem; }
      a.btn { display: inline-block; margin-top: 10px; padding: 8px 12px; background: #0b69c7; color: white; border-radius: 6px; text-decoration: none; }
      a.btn:hover { background: #0a5db0; }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Interview Prep ‚Äì HTML Index&lt;/h1&gt;
    &lt;p class="meta"&gt;Arquivos: %d ‚Ä¢ Tamanho total: %.1f KB ‚Ä¢ Gerado em %s&lt;/p&gt;
    &lt;div class="grid"&gt;%s&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;`

        var cards strings.Builder
        for _, file := range files </span><span class="cov0" title="0">{
                cards.WriteString(fmt.Sprintf(`
      &lt;div class="card"&gt;
        &lt;div class="title"&gt;%s %s&lt;/div&gt;
        &lt;div class="meta"&gt;%s ‚Ä¢ %s KB&lt;/div&gt;
        &lt;a class="btn" href="./%s"&gt;Abrir&lt;/a&gt;
      &lt;/div&gt;`, file.Icon, file.Title, file.Description, file.Size, file.FileName))
        }</span>

        <span class="cov0" title="0">indexHTML := fmt.Sprintf(indexTemplate,
                len(files),
                float64(totalSizeBytes)/1024,
                time.Now().Format("02/01/2006 √†s 15:04"),
                cards.String())

        if err := os.WriteFile(filepath.Join(outputDir, "index.html"), []byte(indexHTML), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write index.html: %w", err)
        }</span>

        // Generate index.json
        <span class="cov0" title="0">idx := map[string]interface{}{
                "generatedAt": time.Now().Format(time.RFC3339),
                "count":       len(files),
                "files":       files,
        }

        data, _ := json.MarshalIndent(idx, "", "  ")
        return os.WriteFile(filepath.Join(outputDir, "index.json"), data, 0644)</span>
}
</pre>

    <pre class="file" id="file4" style="display: none">// Package vscode provides VS Code integration server for LookAtni File Markers.
package vscode

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"

        "github.com/rafa-mori/lookatni-file-markers/internal/parser"
        "github.com/rafa-mori/lookatni-file-markers/internal/transpiler"
        "github.com/rafa-mori/lookatni-file-markers/logger"
)

// Server handles VS Code integration requests.
type Server struct {
        logger     *logger.Logger
        port       int
        parser     *parser.MarkerParser
        transpiler *transpiler.Transpiler
}

// NewServer creates a new VS Code integration server.
func NewServer(log *logger.Logger, port int) *Server <span class="cov0" title="0">{
        // Load default HTML template
        htmlTemplate := `&lt;!doctype html&gt;
&lt;html lang="pt-BR"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
    &lt;title&gt;LookAtni Preview&lt;/title&gt;
    &lt;style&gt;
      body { font-family: system-ui, sans-serif; margin: 2rem; line-height: 1.6; }
      .container { max-width: 900px; margin: 0 auto; }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class="container"&gt;
      {{.Content}}
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;`

        return &amp;Server{
                logger:     log,
                port:       port,
                parser:     parser.New(),
                transpiler: transpiler.New(htmlTemplate),
        }
}</span>

// Start starts the VS Code integration server.
func (s *Server) Start() error <span class="cov0" title="0">{
        mux := http.NewServeMux()

        // API endpoints
        mux.HandleFunc("/api/extract", s.handleExtract)
        mux.HandleFunc("/api/validate", s.handleValidate)
        mux.HandleFunc("/api/transpile", s.handleTranspile)
        mux.HandleFunc("/api/health", s.handleHealth)

        // Enable CORS for VS Code webview
        handler := s.corsMiddleware(mux)

        addr := ":" + strconv.Itoa(s.port)
        s.logger.Info("üåê VS Code integration server listening on %s", addr)

        return http.ListenAndServe(addr, handler)
}</span>

// ExtractRequest represents a file extraction request.
type ExtractRequest struct {
        MarkedFile string                `json:"markedFile"`
        OutputDir  string                `json:"outputDir"`
        Options    parser.ExtractOptions `json:"options"`
}

// ValidateRequest represents a marker validation request.
type ValidateRequest struct {
        MarkedFile string `json:"markedFile"`
}

// TranspileRequest represents a Markdown transpilation request.
type TranspileRequest struct {
        Input     string `json:"input"`
        OutputDir string `json:"outputDir"`
}

// APIResponse represents a standard API response.
type APIResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
}

// handleExtract handles file extraction requests.
func (s *Server) handleExtract(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req ExtractRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, "Invalid request format", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Extract request: %s -&gt; %s", req.MarkedFile, req.OutputDir)

        result, err := s.parser.ExtractFiles(req.MarkedFile, req.OutputDir, req.Options)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, fmt.Sprintf("Extraction failed: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, result)</span>
}

// handleValidate handles marker validation requests.
func (s *Server) handleValidate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req ValidateRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, "Invalid request format", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Validate request: %s", req.MarkedFile)

        result, err := s.parser.ValidateMarkers(req.MarkedFile)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, fmt.Sprintf("Validation failed: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, result)</span>
}

// handleTranspile handles Markdown to HTML transpilation requests.
func (s *Server) handleTranspile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req TranspileRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, "Invalid request format", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Transpile request: %s -&gt; %s", req.Input, req.OutputDir)

        // TODO: Implement transpilation logic similar to CLI
        // For now, return a placeholder response
        result := map[string]interface{}{
                "message": "Transpilation completed",
                "input":   req.Input,
                "output":  req.OutputDir,
        }

        s.sendSuccess(w, result)</span>
}

// handleHealth handles health check requests.
func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "status":  "healthy",
                "service": "lookatni-vscode-integration",
                "version": "2.0.0",
        }
        s.sendSuccess(w, response)
}</span>

// sendSuccess sends a successful API response.
func (s *Server) sendSuccess(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        response := APIResponse{
                Success: true,
                Data:    data,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

// sendError sends an error API response.
func (s *Server) sendError(w http.ResponseWriter, message string, statusCode int) <span class="cov0" title="0">{
        response := APIResponse{
                Success: false,
                Error:   message,
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(response)
}</span>

// corsMiddleware adds CORS headers for VS Code webview communication.
func (s *Server) corsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Allow VS Code webview origins
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                // Handle preflight requests
                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>

    <pre class="file" id="file5" style="display: none">// Package logger provides structured logging for LookAtni File Markers.
package logger

import (
        "fmt"
        "log"
        "os"
        "time"
)

// Config holds logger configuration.
type Config struct {
        Verbose bool
        Prefix  string
}

// Logger provides structured logging with different levels.
type Logger struct {
        verbose bool
        prefix  string
        info    *log.Logger
        warn    *log.Logger
        error   *log.Logger
        debug   *log.Logger
}

// New creates a new logger instance.
func New(config Config) *Logger <span class="cov0" title="0">{
        prefix := config.Prefix
        if prefix == "" </span><span class="cov0" title="0">{
                prefix = "lookatni"
        }</span>

        <span class="cov0" title="0">return &amp;Logger{
                verbose: config.Verbose,
                prefix:  prefix,
                info:    log.New(os.Stdout, fmt.Sprintf("‚úÖ [%s] ", prefix), 0),
                warn:    log.New(os.Stdout, fmt.Sprintf("‚ö†Ô∏è  [%s] ", prefix), 0),
                error:   log.New(os.Stderr, fmt.Sprintf("‚ùå [%s] ", prefix), 0),
                debug:   log.New(os.Stdout, fmt.Sprintf("üîç [%s] ", prefix), 0),
        }</span>
}

// Info logs an info message.
func (l *Logger) Info(format string, args ...interface{}) <span class="cov0" title="0">{
        l.info.Printf(format, args...)
}</span>

// Warn logs a warning message.
func (l *Logger) Warn(format string, args ...interface{}) <span class="cov0" title="0">{
        l.warn.Printf(format, args...)
}</span>

// Error logs an error message.
func (l *Logger) Error(format string, args ...interface{}) <span class="cov0" title="0">{
        l.error.Printf(format, args...)
}</span>

// Debug logs a debug message (only if verbose is enabled).
func (l *Logger) Debug(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.verbose </span><span class="cov0" title="0">{
                l.debug.Printf(format, args...)
        }</span>
}

// WithTimestamp adds timestamp to message.
func (l *Logger) WithTimestamp(format string, args ...interface{}) string <span class="cov0" title="0">{
        timestamp := time.Now().Format("15:04:05")
        return fmt.Sprintf("[%s] %s", timestamp, fmt.Sprintf(format, args...))
}</span>
</pre>

    <pre class="file" id="file6" style="display: none">package main

import (
        "embed"
        "encoding/json"
        "fmt"
        "html"
        "io/fs"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "html/template"

        "github.com/gomarkdown/markdown"
        "github.com/gomarkdown/markdown/ast"

        mhtml "github.com/gomarkdown/markdown/html"
        "github.com/gomarkdown/markdown/parser"
        yaml "gopkg.in/yaml.v3"
)

type mdFileContainer struct {
        ReadFile func(name string) ([]byte, error)
        FileInfo *fs.FileInfo
        Content  []byte
}

type FileInfo struct {
        FileName    string
        Title       string
        Description string
        Size        string
        Icon        string
}

type IndexData struct {
        Files       []FileInfo
        FileCount   int
        TotalSize   string
        GeneratedAt string
}

//go:embed all:tests/interview_*.md
var mdEmbeddedFilesList embed.FS

//go:embed tests/template.html.tmpl
var templateContentByteArr []byte

//go:embed tests/index.html.tmpl
var indexTemplateByteArr []byte

var (
        // mdFiles is initialized with the embedded files
        mdFiles = make(map[string]*mdFileContainer)

        _ = mdFiles
        _ = mdEmbeddedFilesList
)

func main() <span class="cov0" title="0">{
        // Initialize the embedded file system
        mdFilesList, err := mdEmbeddedFilesList.ReadDir("tests")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading embedded files: %v\n", err)
                os.Exit(1)
        }</span>

        // Collect information about generated files for index
        <span class="cov0" title="0">var generatedFiles []FileInfo
        var totalSizeBytes int64

        // Get the target directory
        currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error getting current directory: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">outputPath := filepath.Join(currentDir, "output", "interviews")

        for _, file := range mdFilesList </span><span class="cov0" title="0">{
                if !file.IsDir() &amp;&amp; strings.HasPrefix(file.Name(), "interview_") &amp;&amp; strings.HasSuffix(file.Name(), ".md") </span><span class="cov0" title="0">{
                        // Read the file info
                        fileInfo, err := file.Info()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error getting file info for %s: %v\n", file.Name(), err)
                                continue</span>
                        }

                        <span class="cov0" title="0">mdFiles[file.Name()] = &amp;mdFileContainer{
                                ReadFile: func(name string) ([]byte, error) </span><span class="cov0" title="0">{
                                        return mdEmbeddedFilesList.ReadFile(filepath.Join("tests", name))
                                }</span>,
                                FileInfo: &amp;fileInfo,
                                Content:  make([]byte, 0),
                        }
                        <span class="cov0" title="0">if fileInfo.IsDir() || !strings.HasSuffix(file.Name(), ".md") </span><span class="cov0" title="0">{
                                fmt.Printf("Skipping %s: not a valid source entry\n", file.Name())
                                continue</span>
                        }

                        <span class="cov0" title="0">mdFiles[file.Name()] = &amp;mdFileContainer{
                                ReadFile: func(name string) ([]byte, error) </span><span class="cov0" title="0">{
                                        return mdEmbeddedFilesList.ReadFile(filepath.Join("tests", name))
                                }</span>,
                                FileInfo: &amp;fileInfo,
                                Content:  make([]byte, 0),
                        }

                        <span class="cov0" title="0">containerFile := mdFiles[file.Name()]
                        containerFile.Content, err = mdFiles[file.Name()].ReadFile(file.Name())
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error reading %s: %v\n", file.Name(), err)
                                continue</span>
                        }

                        // Preprocess: frontmatter + fenced prompt blocks ‚Üí custom components
                        <span class="cov0" title="0">pre, _, count := preprocessMarkdown(string(containerFile.Content))

                        htmlFileInfo, err := convertMarkdownToHTML(file.Name(), []byte(pre), count)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error converting %s to HTML: %v\n", file.Name(), err)
                        }</span> else<span class="cov0" title="0"> {
                                generatedFiles = append(generatedFiles, htmlFileInfo)
                                // Get file size for total calculation
                                if stat, err := os.Stat(filepath.Join(outputPath, htmlFileInfo.FileName)); err == nil </span><span class="cov0" title="0">{
                                        totalSizeBytes += stat.Size()
                                }</span>
                        }
                }
        }

        // Generate index.html after all files are processed
        <span class="cov0" title="0">if err := generateIndex(generatedFiles, totalSizeBytes); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error generating index: %v\n", err)
        }</span>
        <span class="cov0" title="0">if err := writeAggregateIndexJSON(generatedFiles); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error writing aggregate index: %v\n", err)
        }</span>
}

func convertMarkdownToHTML(mdFileTitle string, mdFileContent []byte, blockCount int) (FileInfo, error) <span class="cov0" title="0">{
        // Get the target directory
        currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error getting current directory:", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">outputPath := filepath.Join(currentDir, "output", "interviews")
        if err := os.MkdirAll(outputPath, 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error creating output directory:", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">htmlFilePath := filepath.Join(
                outputPath,
                fmt.Sprintf(
                        "./%s_view.html",
                        strings.TrimSuffix(strings.TrimPrefix(mdFileTitle, "interview_"), ".md"),
                ),
        )

        if len(mdFileContent) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Converting", mdFileTitle, "to HTML at", htmlFilePath, ". (", len(mdFileContent), "bytes )")

                // The template content is embedded in the binary
                // And it has the simple structure bellow:
                // {{ .Content | markdown }}

                // Parse the template content
                var templateRenderer = template.Must(
                        template.New("markdown").
                                Option("missingkey=zero").
                                Parse(string(templateContentByteArr)),
                )

                // Convert markdown to HTML first
                extensions := parser.CommonExtensions | parser.AutoHeadingIDs
                p := parser.NewWithExtensions(extensions)
                doc := p.Parse(mdFileContent)

                htmlFlags := mhtml.CommonFlags | mhtml.HrefTargetBlank
                opts := mhtml.RendererOptions{Flags: htmlFlags}
                renderer := mhtml.NewRenderer(opts)

                htmlContent := markdown.Render(doc, renderer)

                // Read the Markdown file content
                var ioWriter = strings.Builder{}

                // Execute the template with the HTML content
                if err := templateRenderer.Execute(&amp;ioWriter, template.HTML(htmlContent)); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error executing template:", err)
                        return FileInfo{}, err
                }</span>

                // Convert the template output to final HTML
                <span class="cov0" title="0">finalHTML := []byte(ioWriter.String())

                // Write the HTML file
                if err = os.WriteFile(htmlFilePath, finalHTML, 0644); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error writing HTML file:", err)
                        return FileInfo{}, err
                }</span>

                <span class="cov0" title="0">fmt.Printf("HTML file %s generated successfully.\n", htmlFilePath)

                // Additionally, write TOC and per-doc index JSONs
                if err := writeTocJSON(doc, outputPath, htmlFilePath); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error writing TOC JSON:", err)
                }</span>
                <span class="cov0" title="0">if err := writeDocIndexJSON(outputPath, htmlFilePath, mdFileTitle, doc, blockCount); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error writing index JSON:", err)
                }</span>

                // Create FileInfo for index
                <span class="cov0" title="0">htmlFileName := filepath.Base(htmlFilePath)
                fileInfo := FileInfo{
                        FileName:    htmlFileName,
                        Title:       generateTitle(mdFileTitle),
                        Description: generateDescription(mdFileTitle),
                        Size:        fmt.Sprintf("%.1f", float64(len(finalHTML))/1024),
                        Icon:        getFileIcon(mdFileTitle),
                }

                return fileInfo, nil</span>
        } else<span class="cov0" title="0"> {
                fmt.Println("No HTML content generated.")
                return FileInfo{}, fmt.Errorf("no content to convert")
        }</span>
}

// generateTitle creates a human-readable title from the markdown filename
func generateTitle(mdFileName string) string <span class="cov0" title="0">{
        // Remove "interview_" prefix and ".md" suffix
        title := strings.TrimPrefix(mdFileName, "interview_")
        title = strings.TrimSuffix(title, ".md")

        // Convert underscores to spaces and capitalize
        title = strings.ReplaceAll(title, "_", " ")
        words := strings.Fields(title)
        for i, word := range words </span><span class="cov0" title="0">{
                if len(word) &gt; 0 </span><span class="cov0" title="0">{
                        words[i] = strings.ToUpper(word[:1]) + word[1:]
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(words, " ")</span>
}

// generateDescription creates a description based on the file type
func generateDescription(mdFileName string) string <span class="cov0" title="0">{
        if strings.Contains(mdFileName, "test") </span><span class="cov0" title="0">{
                return "Vers√£o de teste com perguntas e respostas simuladas para pr√°tica."
        }</span> else<span class="cov0" title="0"> if strings.Contains(mdFileName, "v2") </span><span class="cov0" title="0">{
                return "Vers√£o refinada e polida com respostas mais elaboradas."
        }</span> else<span class="cov0" title="0"> {
                return "Documento principal de prepara√ß√£o com todas as se√ß√µes essenciais."
        }</span>
}

// getFileIcon returns an emoji icon based on the file type
func getFileIcon(mdFileName string) string <span class="cov0" title="0">{
        if strings.Contains(mdFileName, "test") </span><span class="cov0" title="0">{
                return "üß™"
        }</span> else<span class="cov0" title="0"> if strings.Contains(mdFileName, "v2") </span><span class="cov0" title="0">{
                return "‚ú®"
        }</span> else<span class="cov0" title="0"> {
                return "üìã"
        }</span>
}

// generateIndex creates the index.html file with links to all generated files
func generateIndex(files []FileInfo, totalSizeBytes int64) error <span class="cov0" title="0">{
        currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting current directory: %v", err)
        }</span>

        <span class="cov0" title="0">outputPath := filepath.Join(currentDir, "output", "interviews")
        indexPath := filepath.Join(outputPath, "index.html")

        // Prepare data for template
        indexData := IndexData{
                Files:       files,
                FileCount:   len(files),
                TotalSize:   fmt.Sprintf("%.1f", float64(totalSizeBytes)/1024),
                GeneratedAt: time.Now().Format("02/01/2006 √†s 15:04"),
        }

        // Parse the index template
        indexTemplate := template.Must(
                template.New("index").Parse(string(indexTemplateByteArr)),
        )

        // Execute template
        var indexWriter strings.Builder
        if err := indexTemplate.Execute(&amp;indexWriter, indexData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error executing index template: %v", err)
        }</span>

        // Write index.html
        <span class="cov0" title="0">if err := os.WriteFile(indexPath, []byte(indexWriter.String()), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing index file: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Index file %s generated successfully with %d files.\n", indexPath, len(files))
        return nil</span>
}

// writeAggregateIndexJSON writes output/interviews/index.json with basic metadata for search
func writeAggregateIndexJSON(files []FileInfo) error <span class="cov0" title="0">{
        currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">outputPath := filepath.Join(currentDir, "output", "interviews")
        idx := map[string]any{
                "generatedAt": time.Now().Format(time.RFC3339),
                "count":       len(files),
                "files":       files,
        }
        data, _ := json.MarshalIndent(idx, "", "  ")
        return os.WriteFile(filepath.Join(outputPath, "index.json"), data, 0644)</span>
}

// ===== DSL + Frontmatter Preprocess =====

type frontmatter struct {
        Title    any            `yaml:"title"`
        Tags     []string       `yaml:"tags"`
        Context  map[string]any `yaml:"context"`
        Defaults struct {
                Model       string   `yaml:"model"`
                Temperature float64  `yaml:"temperature"`
                ToolHints   []string `yaml:"toolHints"`
        } `yaml:"defaults"`
}

type promptInput struct {
        Name   string   `yaml:"name"`
        Type   string   `yaml:"type"`
        Values []string `yaml:"values"`
}

type promptBody struct {
        Role     string        `yaml:"role"`
        Goal     string        `yaml:"goal"`
        Inputs   []promptInput `yaml:"inputs"`
        Template string        `yaml:"template"`
}

type promptAttrs struct {
        ID        string
        Mode      string
        ToolHints []string
}

var (
        fmRegex     = regexp.MustCompile(`(?s)^---\n(.*?)\n---\n`)
        fenceRegex  = regexp.MustCompile("(?s)```prompt\\s*([^\\n]*)\\n(.*?)```\\s*")
        attrKVRegex = regexp.MustCompile(`(\w+)=([^\s]+)`) // key=value (quote or bracket value allowed)
        quoteTrim   = regexp.MustCompile(`^\"|\"$`)
        bracketTrim = regexp.MustCompile(`^[\[]|[\]]$`)
        listSplit   = regexp.MustCompile(`\s*,\s*`)
)

// preprocessMarkdown parses optional YAML frontmatter and transpiles fenced `prompt` code blocks
// into Kortex custom elements, returning body (without frontmatter), parsed frontmatter, and count.
func preprocessMarkdown(src string) (string, *frontmatter, int) <span class="cov0" title="0">{
        var fm *frontmatter
        // Extract frontmatter if present
        if m := fmRegex.FindStringSubmatch(src); len(m) == 2 </span><span class="cov0" title="0">{
                fm = &amp;frontmatter{}
                if err := yaml.Unmarshal([]byte(m[1]), fm); err != nil </span><span class="cov0" title="0">{
                        // Ignore FM errors; proceed without FM
                        fm = nil
                }</span>
                <span class="cov0" title="0">src = src[len(m[0]):]</span>
        }

        <span class="cov0" title="0">replaced := 0
        out := fenceRegex.ReplaceAllStringFunc(src, func(full string) string </span><span class="cov0" title="0">{
                m := fenceRegex.FindStringSubmatch(full)
                if len(m) != 3 </span><span class="cov0" title="0">{
                        return full
                }</span>
                <span class="cov0" title="0">attrLine := strings.TrimSpace(m[1])
                bodyYAML := strings.TrimSpace(m[2])

                attrs := parsePromptAttrs(attrLine)
                var pb promptBody
                if err := yaml.Unmarshal([]byte(bodyYAML), &amp;pb); err != nil </span><span class="cov0" title="0">{
                        // leave original block if YAML fails
                        return full
                }</span>

                // Defaults from FM + block
                <span class="cov0" title="0">defaults := map[string]any{}
                if fm != nil </span><span class="cov0" title="0">{
                        if fm.Defaults.Model != "" </span><span class="cov0" title="0">{
                                defaults["model"] = fm.Defaults.Model
                        }</span>
                        <span class="cov0" title="0">if fm.Defaults.Temperature != 0 </span><span class="cov0" title="0">{
                                defaults["temperature"] = fm.Defaults.Temperature
                        }</span>
                        <span class="cov0" title="0">if len(fm.Defaults.ToolHints) &gt; 0 </span><span class="cov0" title="0">{
                                defaults["toolHints"] = fm.Defaults.ToolHints
                        }</span>
                }
                <span class="cov0" title="0">if pb.Role != "" </span><span class="cov0" title="0">{
                        defaults["role"] = pb.Role
                }</span>
                <span class="cov0" title="0">if pb.Goal != "" </span><span class="cov0" title="0">{
                        defaults["goal"] = pb.Goal
                }</span>
                <span class="cov0" title="0">if attrs.Mode != "" </span><span class="cov0" title="0">{
                        defaults["mode"] = attrs.Mode
                }</span>
                <span class="cov0" title="0">if len(attrs.ToolHints) &gt; 0 </span><span class="cov0" title="0">{
                        defaults["toolHints"] = attrs.ToolHints
                }</span>

                <span class="cov0" title="0">defJSON, _ := json.Marshal(defaults)
                templateAttr := html.EscapeString(pb.Template)

                // Build inputs HTML
                var fields []string
                for _, in := range pb.Inputs </span><span class="cov0" title="0">{
                        valuesJSON, _ := json.Marshal(in.Values)
                        fields = append(fields, fmt.Sprintf(
                                `&lt;kx-field name="%s" type="%s" values='%s'&gt;&lt;/kx-field&gt;`,
                                html.EscapeString(in.Name), html.EscapeString(in.Type), html.EscapeString(string(valuesJSON)),
                        ))
                }</span>
                <span class="cov0" title="0">inner := strings.Join(fields, "\n  ") + "\n  &lt;button class=\"run\"&gt;Run with MCP&lt;/button&gt;\n  &lt;pre class=\"preview\"&gt;&lt;/pre&gt;"

                htmlBlock := fmt.Sprintf(
                        `&lt;kx-prompt-block data-id="%s" data-defaults='%s' data-template="%s"&gt;
  %s
&lt;/kx-prompt-block&gt;`,
                        html.EscapeString(attrs.ID), html.EscapeString(string(defJSON)), templateAttr, inner,
                )

                replaced++
                return htmlBlock</span>
        })

        <span class="cov0" title="0">return out, fm, replaced</span>
}

func parsePromptAttrs(line string) promptAttrs <span class="cov0" title="0">{
        pa := promptAttrs{}
        for _, m := range attrKVRegex.FindAllStringSubmatch(line, -1) </span><span class="cov0" title="0">{
                if len(m) != 3 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">key := m[1]
                val := m[2]
                // Unwrap quotes or brackets
                if strings.HasPrefix(val, "\"") &amp;&amp; strings.HasSuffix(val, "\"") </span><span class="cov0" title="0">{
                        val = quoteTrim.ReplaceAllString(val, "")
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(val, "[") &amp;&amp; strings.HasSuffix(val, "]") </span><span class="cov0" title="0">{
                        raw := bracketTrim.ReplaceAllString(val, "")
                        items := []string{}
                        for _, it := range listSplit.Split(raw, -1) </span><span class="cov0" title="0">{
                                it = strings.TrimSpace(it)
                                it = quoteTrim.ReplaceAllString(it, "")
                                if it != "" </span><span class="cov0" title="0">{
                                        items = append(items, it)
                                }</span>
                        }
                        <span class="cov0" title="0">if key == "toolHints" </span><span class="cov0" title="0">{
                                pa.ToolHints = items
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "id":<span class="cov0" title="0">
                        pa.ID = val</span>
                case "mode":<span class="cov0" title="0">
                        pa.Mode = val</span>
                case "toolHints":<span class="cov0" title="0">
                        // already handled above if bracket form
                        if val != "" </span><span class="cov0" title="0">{
                                pa.ToolHints = append(pa.ToolHints, val)
                        }</span>
                }
        }
        <span class="cov0" title="0">return pa</span>
}

// writeTocJSON generates a simple toc.json next to the HTML file
func writeTocJSON(doc ast.Node, outDir, htmlPath string) error <span class="cov0" title="0">{
        type tocItem struct {
                Level int    `json:"level"`
                Text  string `json:"text"`
                ID    string `json:"id"`
        }
        var items []tocItem
        ast.WalkFunc(doc, func(n ast.Node, entering bool) ast.WalkStatus </span><span class="cov0" title="0">{
                if !entering </span><span class="cov0" title="0">{
                        return ast.GoToNext
                }</span>
                <span class="cov0" title="0">if h, ok := n.(*ast.Heading); ok </span><span class="cov0" title="0">{
                        // gather text
                        var b strings.Builder
                        for _, c := range n.GetChildren() </span><span class="cov0" title="0">{
                                if t, ok := c.(*ast.Text); ok </span><span class="cov0" title="0">{
                                        b.Write(t.Literal)
                                }</span>
                        }
                        <span class="cov0" title="0">text := b.String()
                        id := slugify(text)
                        items = append(items, tocItem{Level: h.Level, Text: text, ID: id})</span>
                }
                <span class="cov0" title="0">return ast.GoToNext</span>
        })
        <span class="cov0" title="0">data, _ := json.MarshalIndent(items, "", "  ")
        base := strings.TrimSuffix(filepath.Base(htmlPath), filepath.Ext(htmlPath))
        return os.WriteFile(filepath.Join(outDir, base+"_toc.json"), data, 0644)</span>
}

// writeDocIndexJSON writes a minimal index.json per document with metadata and prompt blocks count
func writeDocIndexJSON(outDir, htmlPath, srcName string, doc ast.Node, blockCount int) error <span class="cov0" title="0">{
        // Count kx-prompt-blocks by looking for our injected tags in the rendered HTML is expensive;
        // here we count occurrences in source name for now (simple placeholder), set 0.
        idx := map[string]any{
                "source":      srcName,
                "title":       generateTitle(srcName),
                "blocks":      blockCount,
                "generatedAt": time.Now().Format(time.RFC3339),
        }
        data, _ := json.MarshalIndent(idx, "", "  ")
        base := strings.TrimSuffix(filepath.Base(htmlPath), filepath.Ext(htmlPath))
        return os.WriteFile(filepath.Join(outDir, base+"_index.json"), data, 0644)
}</span>

func slugify(s string) string <span class="cov0" title="0">{
        s = strings.ToLower(s)
        // replace non-alphanum with dash
        var b strings.Builder
        dash := false
        for _, r := range s </span><span class="cov0" title="0">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == ' ' || r == '-' </span><span class="cov0" title="0">{
                        if r == ' ' </span><span class="cov0" title="0">{
                                r = '-'
                        }</span>
                        <span class="cov0" title="0">if r == '-' </span><span class="cov0" title="0">{
                                if dash </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">dash = true</span>
                        } else<span class="cov0" title="0"> {
                                dash = false
                        }</span>
                        <span class="cov0" title="0">b.WriteRune(r)</span>
                }
        }
        <span class="cov0" title="0">out := b.String()
        out = strings.Trim(out, "-")
        return out</span>
}
</pre>

    <pre class="file" id="file7" style="display: none">// Package version provides build-time version information.
package version

var (
        // Version is the semantic version of the application
        Version = "2.0.0-dev"

        // BuildHash is the git commit hash (injected at build time)
        BuildHash = "dev"

        // BuildDate is the build timestamp (injected at build time)
        BuildDate = "dev"

        // GoVersion is the Go version used for building
        GoVersion = "go1.23"
)

// Info returns version information as a structured object.
func Info() map[string]string <span class="cov0" title="0">{
        return map[string]string{
                "version":   Version,
                "buildHash": BuildHash,
                "buildDate": BuildDate,
                "goVersion": GoVersion,
        }
}</span>
</pre>

  </div>
</body>
<script>
  (function () {
    var files = document.getElementById('files');
    var visible;
    files.addEventListener('change', onChange, false);
    function select(part) {
      if (visible)
        visible.style.display = 'none';
      visible = document.getElementById(part);
      if (!visible)
        return;
      files.value = part;
      visible.style.display = 'block';
      location.hash = part;
    }
    function onChange() {
      select(files.value);
      window.scrollTo(0, 0);
    }
    if (location.hash != "") {
      select(location.hash.substr(1));
    }
    if (!visible) {
      select("file0");
    }
  })();
</script>

</html>
