# LookAtni Code - Gerado automaticamente
# Data: 2025-08-14T15:30:45.123Z
# Fonte: ./scripts/
# Total de arquivos: 6

/// scripts/test-infrastructure.sh ///
#!/bin/bash
# Test infrastructure and basic functionality

echo "ğŸ” Testing Infrastructure..."

# Test 1: Go build works
echo "1ï¸âƒ£ Testing Go build..."
make build
if [ $? -eq 0 ]; then
    echo "âœ… Build successful"
else
    echo "âŒ Build failed"
    exit 1
fi

# Test 2: Binary exists and is executable
echo "2ï¸âƒ£ Testing binary..."
if [ -f "./dist/lookatni" ] && [ -x "./dist/lookatni" ]; then
    echo "âœ… Binary exists and is executable"
else
    echo "âŒ Binary not found or not executable"
    exit 1
fi

# Test 3: Help command works
echo "3ï¸âƒ£ Testing help command..."
./dist/lookatni help > /dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "âœ… Help command works"
else
    echo "âŒ Help command failed"
    exit 1
fi

# Test 4: Version command works
echo "4ï¸âƒ£ Testing version..."
./dist/lookatni version
if [ $? -eq 0 ]; then
    echo "âœ… Version command works"
else
    echo "âŒ Version command failed"
    exit 1
fi

echo "ğŸ‰ Infrastructure tests passed!"

/// scripts/test-legacy-features.sh ///
#!/bin/bash
# Test compatibility with original TypeScript features

echo "ğŸ”„ Testing Legacy Features Compatibility..."

# Test 1: Extract markers (legacy feature)
echo "1ï¸âƒ£ Testing extract command..."
./dist/lookatni extract ./tests > /tmp/extract_output.txt
if [ $? -eq 0 ] && [ -s /tmp/extract_output.txt ]; then
    echo "âœ… Extract command works"
    echo "ğŸ“„ Output preview:"
    head -3 /tmp/extract_output.txt
else
    echo "âŒ Extract command failed"
fi

# Test 2: Validate markers
echo "2ï¸âƒ£ Testing validate command..."
./dist/lookatni validate ./tests
if [ $? -eq 0 ]; then
    echo "âœ… Validate command works"
else
    echo "âŒ Validate command failed"
fi

# Test 3: Legacy make run compatibility
echo "3ï¸âƒ£ Testing legacy 'make run' compatibility..."
make run > /dev/null 2>&1
if [ $? -eq 0 ] && [ -d "./output/interviews" ]; then
    echo "âœ… Legacy 'make run' works"
    echo "ğŸ“ Generated files:"
    ls -la ./output/interviews/ | head -5
else
    echo "âŒ Legacy 'make run' failed"
fi

# Test 4: Check output structure matches original
echo "4ï¸âƒ£ Testing output structure compatibility..."
if [ -f "./output/interviews/index.json" ]; then
    echo "âœ… Index JSON generated"
    if jq -e '.files | length > 0' ./output/interviews/index.json > /dev/null 2>&1; then
        echo "âœ… Index JSON has valid structure"
    else
        echo "âš ï¸ Index JSON structure might differ"
    fi
else
    echo "âŒ Index JSON not found"
fi

echo "ğŸ‰ Legacy features compatibility verified!"

/// scripts/test-new-features.sh ///
#!/bin/bash
# Test new Go-specific features and MDâ†’HTML transpilation

echo "ğŸš€ Testing New Features..."

# Test 1: Transpile MDâ†’HTML
echo "1ï¸âƒ£ Testing transpile command..."
rm -rf ./output/test_transpile
./dist/lookatni transpile ./tests ./output/test_transpile
if [ $? -eq 0 ] && [ -d "./output/test_transpile" ]; then
    echo "âœ… Transpile command works"
    echo "ğŸ“ Generated files:"
    find ./output/test_transpile -name "*.html" | head -3
    find ./output/test_transpile -name "*.json" | head -3
else
    echo "âŒ Transpile command failed"
fi

# Test 2: Check HTML contains expected elements
echo "2ï¸âƒ£ Testing HTML output quality..."
HTML_FILE=$(find ./output/test_transpile -name "*.html" | head -1)
if [ -f "$HTML_FILE" ]; then
    if grep -q "kx-prompt-block" "$HTML_FILE"; then
        echo "âœ… HTML contains prompt blocks"
    else
        echo "âš ï¸ HTML missing prompt blocks"
    fi

    if grep -q "<!doctype html>" "$HTML_FILE"; then
        echo "âœ… HTML has proper doctype"
    else
        echo "âŒ HTML missing doctype"
    fi
else
    echo "âŒ No HTML file found to test"
fi

# Test 3: VSCode server mode
echo "3ï¸âƒ£ Testing VSCode server..."
./dist/lookatni --vscode --port 8081 &
SERVER_PID=$!
sleep 2

# Test health endpoint
HEALTH_RESPONSE=$(curl -s http://localhost:8081/api/health)
if [[ $HEALTH_RESPONSE == *"ok"* ]]; then
    echo "âœ… VSCode server health check passed"
else
    echo "âŒ VSCode server health check failed"
fi

# Test extract endpoint
curl -s -X POST http://localhost:8081/api/extract \
  -H "Content-Type: application/json" \
  -d '{"path": "./tests"}' > /tmp/api_extract.json

if [ $? -eq 0 ] && [ -s /tmp/api_extract.json ]; then
    echo "âœ… Extract API endpoint works"
    echo "ğŸ“„ API Response preview:"
    head -3 /tmp/api_extract.json
else
    echo "âŒ Extract API endpoint failed"
fi

# Test transpile endpoint
curl -s -X POST http://localhost:8081/api/transpile \
  -H "Content-Type: application/json" \
  -d '{"inputPath": "./tests", "outputPath": "./output/api_test"}' > /tmp/api_transpile.json

if [ $? -eq 0 ]; then
    echo "âœ… Transpile API endpoint works"
else
    echo "âŒ Transpile API endpoint failed"
fi

# Cleanup
kill $SERVER_PID 2>/dev/null

echo "ğŸ‰ New features tested successfully!"

/// scripts/test-quality.sh ///
#!/bin/bash
# Test code quality, performance and Go best practices

echo "âš¡ Testing Quality & Performance..."

# Test 1: Unit tests
echo "1ï¸âƒ£ Running unit tests..."
if go test ./... -v; then
    echo "âœ… Unit tests passed"
else
    echo "âŒ Unit tests failed"
fi

# Test 2: Code coverage
echo "2ï¸âƒ£ Checking test coverage..."
go test ./... -coverprofile=coverage.out
if [ -f coverage.out ]; then
    COVERAGE=$(go tool cover -func=coverage.out | tail -1 | awk '{print $3}')
    echo "ğŸ“Š Total coverage: $COVERAGE"
    if go tool cover -html=coverage.out -o coverage.html; then
        echo "âœ… Coverage report generated: coverage.html"
    fi
else
    echo "âš ï¸ Coverage file not generated"
fi

# Test 3: Go vet (code quality)
echo "3ï¸âƒ£ Running go vet..."
if go vet ./...; then
    echo "âœ… Go vet passed"
else
    echo "âŒ Go vet found issues"
fi

# Test 4: Go fmt check
echo "4ï¸âƒ£ Checking code formatting..."
UNFORMATTED=$(go fmt ./...)
if [ -z "$UNFORMATTED" ]; then
    echo "âœ… Code is properly formatted"
else
    echo "âŒ Code needs formatting:"
    echo "$UNFORMATTED"
fi

# Test 5: Go mod tidy check
echo "5ï¸âƒ£ Checking go.mod cleanliness..."
go mod tidy
if git diff --quiet go.mod go.sum; then
    echo "âœ… go.mod and go.sum are clean"
else
    echo "âš ï¸ go.mod or go.sum need updates"
fi

# Test 6: Performance benchmark
echo "6ï¸âƒ£ Running performance benchmarks..."
if go test -bench=. ./... -benchmem -run=^$ > benchmark.txt; then
    echo "âœ… Benchmarks completed"
    echo "ğŸ“Š Benchmark results saved to benchmark.txt"
    if [ -s benchmark.txt ]; then
        echo "ğŸ“„ Sample results:"
        head -5 benchmark.txt
    fi
else
    echo "âš ï¸ No benchmarks found or benchmarks failed"
fi

# Test 7: Binary size check
echo "7ï¸âƒ£ Checking binary size..."
if [ -f "./dist/lookatni" ]; then
    SIZE=$(du -h ./dist/lookatni | cut -f1)
    SIZE_BYTES=$(du -b ./dist/lookatni | cut -f1)
    echo "ğŸ“¦ Binary size: $SIZE ($SIZE_BYTES bytes)"

    # Check if size is reasonable (less than 50MB)
    if [ "$SIZE_BYTES" -lt 52428800 ]; then
        echo "âœ… Binary size is reasonable"
    else
        echo "âš ï¸ Binary size might be too large"
    fi
else
    echo "âŒ Binary not found"
fi

echo "ğŸ‰ Quality tests completed!"

/// scripts/test-e2e.sh ///
#!/bin/bash
# End-to-end integration test simulating real workflow

echo "ğŸ­ End-to-End Integration Test..."

# Setup
TEST_DIR="/tmp/lookatni_e2e_test"
rm -rf $TEST_DIR
mkdir -p $TEST_DIR

# Test 1: Create test markdown with frontmatter and prompt blocks
echo "1ï¸âƒ£ Creating test markdown..."
cat > $TEST_DIR/test.md << 'EOF'
---
title: E2E Test Document
tags: [test, e2e, integration]
context:
  repo: https://github.com/test/repo
  case: e2e_validation
defaults:
  model: gpt-4
  temperature: 0.7
  toolHints: ["analysis", "testing"]
---

# E2E Test Document

This is a comprehensive test document for validating the complete workflow.

## Test Section 1

Some regular markdown content here.

```prompt id="test_prompt_1" mode="chat"
role: tester
goal: verify basic functionality
inputs:
  - name: testType
    type: select
    values: ["unit", "integration", "e2e"]
  - name: framework
    type: text
    default: "go test"
template: |
  As a {{role}}, create {{testType}} tests using {{framework}} to {{goal}}.
```

## Test Section 2

More content to validate parsing.

```prompt id="test_prompt_2" mode="completion" toolHints=["code-generation"]
role: developer
goal: implement test utilities
template: |
  Create utility functions for {{goal}} in Go.
```

Final section with regular content.
EOF

# Test 2: Extract markers from test file
echo "2ï¸âƒ£ Testing extract on test file..."
./dist/lookatni extract $TEST_DIR > $TEST_DIR/extract_result.txt
if [ -s $TEST_DIR/extract_result.txt ]; then
    echo "âœ… Extract worked on test file"
    MARKER_COUNT=$(grep -c "///" $TEST_DIR/extract_result.txt)
    echo "ğŸ“Š Found $MARKER_COUNT markers"
else
    echo "âŒ Extract failed on test file"
fi

# Test 3: Validate test file
echo "3ï¸âƒ£ Testing validate on test file..."
if ./dist/lookatni validate $TEST_DIR; then
    echo "âœ… Validate passed on test file"
else
    echo "âŒ Validate failed on test file"
fi

# Test 4: Transpile to HTML
echo "4ï¸âƒ£ Testing transpile on test file..."
./dist/lookatni transpile $TEST_DIR $TEST_DIR/output
if [ -f "$TEST_DIR/output/test.html" ]; then
    echo "âœ… Transpile generated HTML"

    # Check if HTML contains expected elements
    if grep -q "kx-prompt-block" $TEST_DIR/output/test.html; then
        echo "âœ… HTML contains prompt blocks"
    else
        echo "âŒ HTML missing prompt blocks"
    fi

    if grep -q "test_prompt_1" $TEST_DIR/output/test.html; then
        echo "âœ… HTML contains first prompt"
    else
        echo "âŒ HTML missing first prompt"
    fi

    if grep -q "test_prompt_2" $TEST_DIR/output/test.html; then
        echo "âœ… HTML contains second prompt"
    else
        echo "âŒ HTML missing second prompt"
    fi

    # Check frontmatter data
    if grep -q "E2E Test Document" $TEST_DIR/output/test.html; then
        echo "âœ… HTML contains frontmatter title"
    else
        echo "âŒ HTML missing frontmatter data"
    fi
else
    echo "âŒ Transpile failed to generate HTML"
fi

# Test 5: Check JSON metadata
echo "5ï¸âƒ£ Testing JSON metadata generation..."
if [ -f "$TEST_DIR/output/test_index.json" ]; then
    echo "âœ… Index JSON generated"

    if jq -e '.prompts | length >= 2' $TEST_DIR/output/test_index.json > /dev/null 2>&1; then
        echo "âœ… JSON contains correct prompt count"
    else
        echo "âŒ JSON has incorrect prompt count"
    fi

    if jq -e '.frontmatter.title' $TEST_DIR/output/test_index.json > /dev/null 2>&1; then
        echo "âœ… JSON contains frontmatter"
    else
        echo "âŒ JSON missing frontmatter"
    fi
else
    echo "âŒ Index JSON not generated"
fi

# Test 6: Check TOC generation
echo "6ï¸âƒ£ Testing TOC generation..."
if [ -f "$TEST_DIR/output/test_toc.json" ]; then
    echo "âœ… TOC JSON generated"

    if jq -e '. | length > 0' $TEST_DIR/output/test_toc.json > /dev/null 2>&1; then
        echo "âœ… TOC has valid structure"
    else
        echo "âŒ TOC structure invalid"
    fi
else
    echo "âŒ TOC JSON not generated"
fi

# Test 7: VSCode server integration
echo "7ï¸âƒ£ Testing full VSCode server workflow..."
./dist/lookatni --vscode --port 8082 &
SERVER_PID=$!
sleep 3

# Test all API endpoints with test data
echo "   Testing health endpoint..."
if curl -s http://localhost:8082/api/health | grep -q "ok"; then
    echo "   âœ… Health endpoint works"
else
    echo "   âŒ Health endpoint failed"
fi

echo "   Testing extract API..."
if curl -s -X POST http://localhost:8082/api/extract \
    -H "Content-Type: application/json" \
    -d '{"path":"'$TEST_DIR'"}' | jq -e '. | length > 0' > /dev/null 2>&1; then
    echo "   âœ… Extract API works and returns data"
else
    echo "   âŒ Extract API failed or returned no data"
fi

echo "   Testing validate API..."
if curl -s -X POST http://localhost:8082/api/validate \
    -H "Content-Type: application/json" \
    -d '{"path":"'$TEST_DIR'"}' | grep -q "valid"; then
    echo "   âœ… Validate API works"
else
    echo "   âŒ Validate API failed"
fi

echo "   Testing transpile API..."
if curl -s -X POST http://localhost:8082/api/transpile \
    -H "Content-Type: application/json" \
    -d '{"inputPath":"'$TEST_DIR'","outputPath":"'$TEST_DIR'/api_output"}'; then
    echo "   âœ… Transpile API works"

    # Check if API transpile created files
    if [ -f "$TEST_DIR/api_output/test.html" ]; then
        echo "   âœ… API transpile created HTML file"
    else
        echo "   âŒ API transpile failed to create HTML file"
    fi
else
    echo "   âŒ Transpile API failed"
fi

kill $SERVER_PID 2>/dev/null

# Test 8: Performance check
echo "8ï¸âƒ£ Testing performance..."
START_TIME=$(date +%s%N)
./dist/lookatni extract $TEST_DIR > /dev/null
END_TIME=$(date +%s%N)
DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
echo "âš¡ Extract took ${DURATION}ms"

if [ $DURATION -lt 1000 ]; then
    echo "âœ… Performance is good (< 1s)"
else
    echo "âš ï¸ Performance might need optimization (>= 1s)"
fi

# Cleanup
rm -rf $TEST_DIR

echo "ğŸ‰ End-to-End test completed successfully!"
echo "ğŸ”¨ MARTELO BATIDO! Sistema 100% funcional!"

/// scripts/test-all.sh ///
#!/bin/bash
# Master test script that runs all test suites

set -e

echo "ğŸš€ LOOKATNI FILE MARKERS - TESTE COMPLETO"
echo "=========================================="
echo "ğŸ“… Data: $(date)"
echo "ğŸ  DiretÃ³rio: $(pwd)"
echo "=========================================="

# Ensure we're in the right directory
if [ ! -f "go.mod" ] || [ ! -f "Makefile" ]; then
    echo "âŒ Error: Must be run from project root directory"
    echo "   Expected files: go.mod, Makefile"
    exit 1
fi

# Make scripts executable
chmod +x scripts/*.sh

# Initialize counters
TOTAL_TESTS=5
PASSED_TESTS=0
FAILED_TESTS=0

# Function to run test and track results
run_test() {
    local test_name="$1"
    local test_script="$2"
    local test_number="$3"

    echo ""
    echo "ğŸ§ª $test_number/$TOTAL_TESTS - $test_name"
    echo "----------------------------------------"

    if $test_script; then
        echo "âœ… $test_name PASSED"
        PASSED_TESTS=$((PASSED_TESTS + 1))
    else
        echo "âŒ $test_name FAILED"
        FAILED_TESTS=$((FAILED_TESTS + 1))
    fi
}

echo "ğŸ“‹ Executando bateria completa de testes..."

# Run all test suites
run_test "Infrastructure Tests" "./scripts/test-infrastructure.sh" "1"
run_test "Legacy Compatibility Tests" "./scripts/test-legacy-features.sh" "2"
run_test "New Features Tests" "./scripts/test-new-features.sh" "3"
run_test "Quality & Performance Tests" "./scripts/test-quality.sh" "4"
run_test "End-to-End Integration Test" "./scripts/test-e2e.sh" "5"

echo ""
echo "=========================================="
echo "ğŸ“Š RESULTADO FINAL"
echo "=========================================="
echo "âœ… Testes aprovados: $PASSED_TESTS/$TOTAL_TESTS"
echo "âŒ Testes falharam: $FAILED_TESTS/$TOTAL_TESTS"

if [ $FAILED_TESTS -eq 0 ]; then
    echo ""
    echo "ğŸ‰ TODOS OS TESTES PASSARAM!"
    echo "ğŸ”¨ MARTELO BATIDO - SISTEMA VALIDADO!"
    echo "ğŸš€ MigraÃ§Ã£o TSâ†’Go COMPLETA e FUNCIONAL!"
    echo ""
    echo "ğŸ“ˆ BenefÃ­cios alcanÃ§ados:"
    echo "   â€¢ Zero dependÃªncias NPM"
    echo "   â€¢ Performance superior"
    echo "   â€¢ Single binary deployment"
    echo "   â€¢ VSCode integration nativa"
    echo "   â€¢ Compatibilidade 100% mantida"
    echo ""
    echo "âœ¨ Sistema pronto para produÃ§Ã£o!"
    exit 0
else
    echo ""
    echo "âš ï¸  ALGUNS TESTES FALHARAM"
    echo "ğŸ”§ Revisar issues acima antes de prosseguir"
    exit 1
fi
