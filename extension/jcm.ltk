/// .codex/config.toml ///
[settings]
model_reasoning_summary = "concise"
user_intent_summary     = "detailed"
project_summary         = "detailed"
default_max_tokens_out  = 700
fail_fast               = true
temperature             = 0.1

[manifests]
# cada repo ter√° estes princ√≠pios leves sempre no contexto
paths = [
  "docs/brand/**/kubex_brand_visual_spec*.md",
  "docs/architecture/**/Resilience-by-Design*.md",
  "docs/governance/**/KUBEX_MANIFESTO*.md"
]
max_tokens = 300
update_strategy = "incremental"
priority = "high"

[context]
scopes = [
  { name = "objective",   max_tokens = 120, summarization = "bullet_goals" },
  { name = "constraints", max_tokens = 120, summarization = "hard_rules"   },
  { name = "facts",       max_tokens = 200, summarization = "code_facts"   },
  { name = "delta",       max_tokens = 180, summarization = "git_diff"     },
  { name = "plan",        max_tokens = 160, summarization = "step_plan"    },
  { name = "exec",        max_tokens = 120, summarization = "checklist"    }
]
eviction_order = ["exec", "plan", "delta"]

[output]
style = "succinct_actionable"
postamble = "‚úÖ Valide: build/test passam e objetivo foi atendido."
# foco em produto: n√£o deixar ‚Äúrelat√≥rios de tarefa‚Äù no repo
generate_task_summaries = false
allow_repo_writing_of_reports = false

# ajuste a confian√ßa conforme o repo
[projects]
# exemplo: substitua <REPO_NAME> ou remova se preferir dete√ß√£o autom√°tica
"/<ABS_PATH>/<REPO_NAME>" = { trust_level = "trusted" }

[guards]
dangerous_patterns    = ["rm -rf", "dd if=", "mkfs", "drop table", "helm uninstall --all"]
require_confirmation  = true
auto_dry_run          = true

[behaviors]
goal_driven_context   = true
prefer_recent_diffs   = true
refuse_when_unsafe    = true

[summarizers]
bullet_goals = """
- 3‚Äì5 bullets com verbo imperativo + artefato esperado.
"""
hard_rules = """
- Restri√ß√µes duras (build tags, compatibilidade, lint), sem opini√£o est√©tica.
"""
code_facts = """
- Fatos verific√°veis do c√≥digo (assinaturas, tipos, caminhos), sem interpreta√ß√£o.
"""
git_diff = """
- Mudan√ßas por arquivo; +fun√ß√µes, -removidas, contratos alterados; destaque breaking.
"""
step_plan = """
- 3‚Äì6 passos at√¥micos, cada um com checagem objetiva.
"""
checklist = """
- Checklist [ ] execut√°vel.
"""
/// .kubex/config.toml ///
Este arquivo seria a fonte da verdade para o internal/config/loader.go
Mantendo a estrutura que definimos anteriormente.
[settings]
model_reasoning_summary = "concise"

[manifests]
paths = [
".kubex/docs/brand/kubex_brand_visual_spec.v0.0.1.md",
".kubex/docs/architecture/Resilience-by-Design.md",
".kubex/docs/governance/KUBEX_MANIFESTO.md"
]

... resto da configura√ß√£o ...
/// .kubex/docs/governance/AI_SQUAD_ROLES.md ///
Pap√©is da AI Squad ‚Äî Ecossistema Kubex
Mantendo o documento que define os pap√©is como parte da configura√ß√£o base.

// (e assim por diante para os outros manifestos) //
/// .vscode/keybindings.json ///
[
  { "key": "ctrl+alt+o", "command": "codex.ide.runObjective" },
  { "key": "ctrl+alt+p", "command": "codex.ide.planFromChanges" },
  { "key": "ctrl+alt+d", "command": "codex.ide.applyDiffSafely" },
  { "key": "ctrl+alt+t", "command": "codex.ide.toggleTrace" }
]
/// .vscode/settings.json ///
{
  "codex.ide.manifests.paths": [
    "docs/brand/**/kubex_brand_visual_spec*.md",
    "docs/architecture/**/Resilience-by-Design*.md",
    "docs/governance/**/KUBEX_MANIFESTO*.md"
  ],
  "codex.ide.manifests.maxTokens": 300,
  "codex.ide.manifests.updateStrategy": "incremental",
  "codex.ide.output.style": "succinct_actionable",
  "codex.ide.output.postamble": "‚úÖ Valide: build/test passam e objetivo foi atendido.",
  "codex.ide.context.goalDriven": true,
  "codex.ide.context.evictionOrder": ["exec", "plan", "delta"],
  "codex.ide.scopes": [
    { "name": "objective",   "maxTokens": 120, "summarization": "bullet_goals" },
    { "name": "constraints", "maxTokens": 120, "summarization": "hard_rules"   },
    { "name": "facts",       "maxTokens": 200, "summarization": "code_facts"   },
    { "name": "delta",       "maxTokens": 180, "summarization": "git_diff"     },
    { "name": "plan",        "maxTokens": 160, "summarization": "step_plan"    },
    { "name": "exec",        "maxTokens": 120, "summarization": "checklist"    }
  ],
  "codex.ide.summarizers": {
    "bullet_goals": "- 3‚Äì5 bullets com verbo imperativo + artefato esperado.",
    "hard_rules": "- Restri√ß√µes duras (build tags, compatibilidade, lint), sem opini√£o est√©tica.",
    "code_facts": "- Fatos verific√°veis do c√≥digo (assinaturas, tipos, caminhos), sem interpreta√ß√£o.",
    "git_diff": "- Mudan√ßas por arquivo; +fun√ß√µes, -removidas, contratos alterados; destaque breaking.",
    "step_plan": "- 3‚Äì6 passos at√¥micos, cada um com checagem objetiva.",
    "checklist": "- Checklist [ ] execut√°vel."
  },
  "codex.ide.projects": {
    "/<ABS_PATH>/<REPO_NAME>": {
      "trustLevel": "trusted",
      "languageBias": ["go","ts","tsx","bash","make","md","rust","wasm"],
      "rules": [
        "Sem relat√≥rios de tarefa no repo; apenas artefatos de produto.",
        "Tests e linters como fonte de verdade.",
        "Padr√µes Kubex e Brand visual consistentes."
      ]
    }
  },
  "codex.ide.guards.dangerousPatterns": ["rm -rf","dd if=","mkfs","drop table","helm uninstall --all"],
  "codex.ide.guards.requireConfirmation": true,
  "codex.ide.guards.autoDryRun": true,

  "editor.formatOnSave": true,
  "files.trimFinalNewlines": true,

  "github.copilot.inlineSuggest.enable": true,
  "github.copilot.editor.enableAutoCompletions": true,
  "github.copilot.enable": { "*": true, "markdown": false, "plaintext": false, "yaml": false },
  "github.copilot.advanced": { "excludedFolders": ["docs/brand","docs/architecture","docs/governance",".codex"] }
}
/// .vscode/tasks.json ///
{
  "version": "2.0.0",
  "tasks": [
    { "label": "codex: objective (CLI)", "type": "shell", "command": "codex-cli objective --trace=summary" },
    { "label": "codex: plan from git diff", "type": "shell", "command": "git diff | codex-cli plan --stdin --fail-fast" },
    { "label": "codex: apply (dry-run)", "type": "shell", "command": "codex-cli apply --dry-run" },
    { "label": "codex: apply (confirm)", "type": "shell", "command": "codex-cli apply --yes" }
  ]
}
/// README.md ///
# kbx - O Maestro da Squad de IAs do Kubex

`kbx` √© a ferramenta de linha de comando que serve como ponto de entrada √∫nico e abstrato para o ecossistema de desenvolvimento assistido por IA do Kubex. Ele orquestra os diferentes agentes (`codex`, `g-agent`, `copilot`) para garantir que cada contribui√ß√£o, de qualquer colaborador, esteja alinhada com os princ√≠pios e a qualidade definidos no Manifesto Kubex.

> **Nosso lema:** Um comando para come√ßar. A filosofia do projeto para garantir a qualidade.

## üöÄ In√≠cio R√°pido

### Pr√©-requisitos

- Go 1.25+
- Make

### Instala√ß√£o

```bash
# Compila e instala o bin√°rio kbx no seu GOPATH/bin
make install
Configura√ß√£o
O kbx √© projetado para funcionar out-of-the-box em um reposit√≥rio Kubex. Ele procura automaticamente por uma pasta .kubex/ contendo os arquivos de configura√ß√£o e manifestos.

üõ†Ô∏è Uso B√°sico
Verifique se o ambiente est√° pronto:

Bash

kbx doctor
Inicie uma nova tarefa com um objetivo claro:

Bash

kbx objective "Refatorar o parser de configura√ß√£o para suportar a nova flag --strict"
Audite suas mudan√ßas atuais contra os princ√≠pios do projeto:

Bash

kbx audit
Prepare seu commit, garantindo a conformidade com os padr√µes:

Bash

kbx commit
/// docs/architecture/Resilience-by-Design.md ///
# Resilience by Design ‚Äî Kortex/Kubex (Outline)

> Descrever a arquitetura resiliente e o ‚Äúoffline-first com melhoria progressiva‚Äù.
> Documento curto e objetivo, focado em produto.

## 1. Princ√≠pios
- *Offline-first*, reconex√£o autom√°tica, *event broadcasting* interno
- UI com indicadores de conectividade e frescor
- Fallback seguro sem MCP, upgrades com WebSockets quando presente

## 2. Padr√£o de Estados
- `AppContext` global (Next.js/TS strict)
- Filas de eventos, handlers idempotentes
- Retentativas com *backoff* e circuit breakers

## 3. Integra√ß√£o MCP
- Conex√£o WebSocket com reconex√£o
- Logs e m√©tricas em tempo real
- Estrat√©gia de degrada√ß√£o graciosa

## 4. Build/Deploy
- Static export (`output: 'export'`) para GitHub Pages
- Imagens `unoptimized: true`, trailingSlash
- CI com lint/test/build e checagens de qualidade

## 5. Aceite
- Build est√°vel
- Sem *runtime errors* offline
- Realtime upgrades funcionando quando MCP dispon√≠vel
/// docs/brand/kubex_brand_visual_spec.v0.0.1.md ///
# Kubex Brand Visual Spec
A visual identity guide for all Kubex modules and projects. This document ensures consistent branding across repositories, banners, and promotional assets.

## üé® Color Palette
- **Base / Background**: Deep dark blue-black (`#0a0f14` ‚Üí `#10151b`), subtle grid/dots
- **Primary**: Ciano `#00f0ff`, Verde `#00e676`
- **Secondary**: Roxo `#7c4dff`, Lil√°s `#8e24aa`
- **Contrast/Text**: `#e0f7fa`

## üî§ Typography
- **Title**: futuristic sans (Orbitron/Exo2/Bank Gothic), uppercase + neon glow
- **Subtitle**: monospace (IBM Plex Mono/Source Code Pro), sutil

## üî∑ Elements
Hex√°gonos com outline neon, linhas de conex√£o finas, grid/circuitos, √≠cones minimalistas (Docker, Helm, chat, charts). Radial glow sutil atr√°s do t√≠tulo.

## üìê Composition
1) T√≠tulo central (neon)  
2) Subt√≠tulo curto abaixo  
3) √çcones perif√©ricos em hex√°gonos conectados  
4) Espa√ßo para ‚Äúrespirar‚Äù (sem polui√ß√£o visual)

## üß© Modular Abstraction
- Mesmo DNA visual; cor prim√°ria distinta por m√≥dulo (ex.: GHbex‚ÜíCiano, Kortex‚ÜíTeal, Logz‚ÜíGreen, GoBE‚ÜíPurple)
- √çcones relevantes por dom√≠nio
- Composi√ß√£o consistente

## ‚úÖ Checklist de uso
- [ ] Background dark + textura leve
- [ ] T√≠tulo central neon
- [ ] Subt√≠tulo monospace
- [ ] 2‚Äì3 √≠cones perif√©ricos
- [ ] Linhas finas conectando
- [ ] Cor prim√°ria do m√≥dulo
- [ ] Grid sutil ao fundo
/// docs/governance/KUBEX_MANIFESTO.md ///
# Kubex ‚Äî Manifesto de Co-Autoria (Agentes Cofundadores)

> **Princ√≠pio**: agentes n√£o ‚Äúentregam tarefas‚Äù, **entregam produto**. Nada de arquivos de relato de tarefa no repo.

## Diretrizes
1. **Objetivo verific√°vel**: cada change precisa de resultado observ√°vel (build/test/endpoint/UX).
2. **Sem task-reports**: bloquear `TASK_SUMMARY*.md`, `agent_report*.md` e afins.
3. **Documenta√ß√£o √∫til**: README/guia/ADRs curtos; nada de di√°rios de execu√ß√£o.
4. **Consist√™ncia Kubex**: seguir Brand Visual + Craftsmanship Standards (Go/TS).
5. **Qualidade**: testes, lint, security checks.

## ‚ÄúDone‚Äù
- ‚úÖ Build ok, sem warnings cr√≠ticos
- ‚úÖ Testes cobrindo paths felizes/erro
- ‚úÖ Docs de uso atualizados quando aplic√°vel
- ‚úÖ Nenhum relat√≥rio de tarefa inserido
/// docs/module-spec.md ///
# Module Specification

```go
// Module is an interface that defines the methods a module must implement.
type Module interface {
  Alias() string
  ShortDescription() string
  LongDescription() string
  Usage() string
  Examples() []string
  Active() bool
  Module() string
  Execute() error
  Command() *cobra.Command
  SetParentCmdName(rtCmd string)
  concatenateExamples() string
}
```

```go
// Simple Generic Module Concrete Case
type ModuleConcrete struct {
 parentCmdName string
 printBanner   bool
}

/*
  Abaixo est√£o os m√©todos que representam wrappers
  de dados b√°sicos do m√≥dulo, enquanto CLI e Lib.

  Esses m√©todos s√£o obrigat√≥rios para qualquer m√≥dulo.
 */
func (m *ModuleConcrete) Alias() string {
 return "module"
}
func (m *ModuleConcrete) ShortDescription() string {
 return "ModuleConcrete short description."
}
func (m *ModuleConcrete) LongDescription() string {
 return `ModuleConcrete long description.`
}
func (m *ModuleConcrete) Usage() string {
 return "module [command] [args]"
}
func (m *ModuleConcrete) Examples() []string {
 return []string{
  "module doctor <subcommand>",
  "module platform <subcommand>",
 }
}
func (m *ModuleConcrete) Active() bool {
 return true
}
func (m *ModuleConcrete) Module() string {
 return "module"
}
func (m *ModuleConcrete) Execute() error {
 return m.Command().Execute()
}

func (m *ModuleConcrete) Command() *cobra.Command {
/*
  Todo m√≥dulo, pode opcionalmente usar o `Annotations`
  como uma camada de metadados para o comando.
  Ele cont√©m dois argumentos:
    - Descriptions: []string{}
      Ele ir√° lidar com os Short e Long descriptions
      contemplando a abstra√ß√£o que h√° trazendo estiliza√ß√£o
      e formata√ß√£o.

    - hideBanner: bool
      Se verdadeiro, oculta a exibi√ß√£o do banner do m√≥dulo e
      torna o comportamento do Cobra em rela√ß√£o ao Short e Long
      descriptions nativo novamente.
 */

 rootCmd := &cobra.Command{
  Use:   m.Module(),
  Alias: m.Alias(),
  Short: m.ShortDescription(),
  Long:  m.LongDescription(),
  // Aqui h√° um tratamento quebrando as linhas do
  // array de exemplos na exibi√ß√£o. Permitindo
  // que seja ve√≠culado v√°rios exemplos para o mesmo comando
  // de forma organizada.
  Example: m.concatenateExamples(),

  Annotations: m.GetDescriptions(
    []string{
      m.ShortDescription(),
      m.LongDescription(),
    }, m.printBanner,
  ),
  RunE: func(cmd *cobra.Command, args []string) error {
   return m.Execute()
  },
 }

// Aqui voc√™ pode adicionar subcomandos ao comando raiz
// Ex: rootCmd.AddCommand(subCmd1, subCmd2)

// Ap√≥s inserir os comandos, √© necess√°rio acionar o
// registro do template e cores para o Cobra.
// Isso faz com que o CLI tenha uma apar√™ncia
// mais amig√°vel e estilizada, al√©m de padronizada
// para todos os m√≥dulos do ecossistema.
 setUsageDefinition(rtCmd)

 // Esse loop existe para garantir que os padr√µes de
 // estilo tamb√©m sejam aplicados aos subcomandos.
 for _, c := range rtCmd.Commands() {
  setUsageDefinition(c)
  if !strings.Contains(strings.Join(os.Args, " "), c.Use) {
   if c.Short == "" {
    c.Short = c.Annotations["description"]
   }
  }
 }

// Retorna o comando completo.
 return rootCmd
}
```
/// jcm.ltk ///
/// .codex/config.toml ///
[settings]
model_reasoning_summary = "concise"
user_intent_summary     = "detailed"
project_summary         = "detailed"
default_max_tokens_out  = 700
fail_fast               = true
temperature             = 0.1

[manifests]
# cada repo ter√° estes princ√≠pios leves sempre no contexto
paths = [
  "docs/brand/**/kubex_brand_visual_spec*.md",
  "docs/architecture/**/Resilience-by-Design*.md",
  "docs/governance/**/KUBEX_MANIFESTO*.md"
]
max_tokens = 300
update_strategy = "incremental"
priority = "high"

[context]
scopes = [
  { name = "objective",   max_tokens = 120, summarization = "bullet_goals" },
  { name = "constraints", max_tokens = 120, summarization = "hard_rules"   },
  { name = "facts",       max_tokens = 200, summarization = "code_facts"   },
  { name = "delta",       max_tokens = 180, summarization = "git_diff"     },
  { name = "plan",        max_tokens = 160, summarization = "step_plan"    },
  { name = "exec",        max_tokens = 120, summarization = "checklist"    }
]
eviction_order = ["exec", "plan", "delta"]

[output]
style = "succinct_actionable"
postamble = "‚úÖ Valide: build/test passam e objetivo foi atendido."
# foco em produto: n√£o deixar ‚Äúrelat√≥rios de tarefa‚Äù no repo
generate_task_summaries = false
allow_repo_writing_of_reports = false

# ajuste a confian√ßa conforme o repo
[projects]
# exemplo: substitua <REPO_NAME> ou remova se preferir dete√ß√£o autom√°tica
"/<ABS_PATH>/<REPO_NAME>" = { trust_level = "trusted" }

[guards]
dangerous_patterns    = ["rm -rf", "dd if=", "mkfs", "drop table", "helm uninstall --all"]
require_confirmation  = true
auto_dry_run          = true

[behaviors]
goal_driven_context   = true
prefer_recent_diffs   = true
refuse_when_unsafe    = true

[summarizers]
bullet_goals = """
- 3‚Äì5 bullets com verbo imperativo + artefato esperado.
"""
hard_rules = """
- Restri√ß√µes duras (build tags, compatibilidade, lint), sem opini√£o est√©tica.
"""
code_facts = """
- Fatos verific√°veis do c√≥digo (assinaturas, tipos, caminhos), sem interpreta√ß√£o.
"""
git_diff = """
- Mudan√ßas por arquivo; +fun√ß√µes, -removidas, contratos alterados; destaque breaking.
"""
step_plan = """
- 3‚Äì6 passos at√¥micos, cada um com checagem objetiva.
"""
checklist = """
- Checklist [ ] execut√°vel.
"""
/// .kubex/config.toml ///
Este arquivo seria a fonte da verdade para o internal/config/loader.go
Mantendo a estrutura que definimos anteriormente.
[settings]
model_reasoning_summary = "concise"

[manifests]
paths = [
".kubex/docs/brand/kubex_brand_visual_spec.v0.0.1.md",
".kubex/docs/architecture/Resilience-by-Design.md",
".kubex/docs/governance/KUBEX_MANIFESTO.md"
]

... resto da configura√ß√£o ...
/// .kubex/docs/governance/AI_SQUAD_ROLES.md ///
Pap√©is da AI Squad ‚Äî Ecossistema Kubex
Mantendo o documento que define os pap√©is como parte da configura√ß√£o base.

// (e assim por diante para os outros manifestos) //
/// .vscode/keybindings.json ///
[
  { "key": "ctrl+alt+o", "command": "codex.ide.runObjective" },
  { "key": "ctrl+alt+p", "command": "codex.ide.planFromChanges" },
  { "key": "ctrl+alt+d", "command": "codex.ide.applyDiffSafely" },
  { "key": "ctrl+alt+t", "command": "codex.ide.toggleTrace" }
]
/// .vscode/settings.json ///
{
  "codex.ide.manifests.paths": [
    "docs/brand/**/kubex_brand_visual_spec*.md",
    "docs/architecture/**/Resilience-by-Design*.md",
    "docs/governance/**/KUBEX_MANIFESTO*.md"
  ],
  "codex.ide.manifests.maxTokens": 300,
  "codex.ide.manifests.updateStrategy": "incremental",
  "codex.ide.output.style": "succinct_actionable",
  "codex.ide.output.postamble": "‚úÖ Valide: build/test passam e objetivo foi atendido.",
  "codex.ide.context.goalDriven": true,
  "codex.ide.context.evictionOrder": ["exec", "plan", "delta"],
  "codex.ide.scopes": [
    { "name": "objective",   "maxTokens": 120, "summarization": "bullet_goals" },
    { "name": "constraints", "maxTokens": 120, "summarization": "hard_rules"   },
    { "name": "facts",       "maxTokens": 200, "summarization": "code_facts"   },
    { "name": "delta",       "maxTokens": 180, "summarization": "git_diff"     },
    { "name": "plan",        "maxTokens": 160, "summarization": "step_plan"    },
    { "name": "exec",        "maxTokens": 120, "summarization": "checklist"    }
  ],
  "codex.ide.summarizers": {
    "bullet_goals": "- 3‚Äì5 bullets com verbo imperativo + artefato esperado.",
    "hard_rules": "- Restri√ß√µes duras (build tags, compatibilidade, lint), sem opini√£o est√©tica.",
    "code_facts": "- Fatos verific√°veis do c√≥digo (assinaturas, tipos, caminhos), sem interpreta√ß√£o.",
    "git_diff": "- Mudan√ßas por arquivo; +fun√ß√µes, -removidas, contratos alterados; destaque breaking.",
    "step_plan": "- 3‚Äì6 passos at√¥micos, cada um com checagem objetiva.",
    "checklist": "- Checklist [ ] execut√°vel."
  },
  "codex.ide.projects": {
    "/<ABS_PATH>/<REPO_NAME>": {
      "trustLevel": "trusted",
      "languageBias": ["go","ts","tsx","bash","make","md","rust","wasm"],
      "rules": [
        "Sem relat√≥rios de tarefa no repo; apenas artefatos de produto.",
        "Tests e linters como fonte de verdade.",
        "Padr√µes Kubex e Brand visual consistentes."
      ]
    }
  },
  "codex.ide.guards.dangerousPatterns": ["rm -rf","dd if=","mkfs","drop table","helm uninstall --all"],
  "codex.ide.guards.requireConfirmation": true,
  "codex.ide.guards.autoDryRun": true,

  "editor.formatOnSave": true,
  "files.trimFinalNewlines": true,

  "github.copilot.inlineSuggest.enable": true,
  "github.copilot.editor.enableAutoCompletions": true,
  "github.copilot.enable": { "*": true, "markdown": false, "plaintext": false, "yaml": false },
  "github.copilot.advanced": { "excludedFolders": ["docs/brand","docs/architecture","docs/governance",".codex"] }
}
/// .vscode/tasks.json ///
{
  "version": "2.0.0",
  "tasks": [
    { "label": "codex: objective (CLI)", "type": "shell", "command": "codex-cli objective --trace=summary" },
    { "label": "codex: plan from git diff", "type": "shell", "command": "git diff | codex-cli plan --stdin --fail-fast" },
    { "label": "codex: apply (dry-run)", "type": "shell", "command": "codex-cli apply --dry-run" },
    { "label": "codex: apply (confirm)", "type": "shell", "command": "codex-cli apply --yes" }
  ]
}
/// README.md ///
# kbx - O Maestro da Squad de IAs do Kubex

`kbx` √© a ferramenta de linha de comando que serve como ponto de entrada √∫nico e abstrato para o ecossistema de desenvolvimento assistido por IA do Kubex. Ele orquestra os diferentes agentes (`codex`, `g-agent`, `copilot`) para garantir que cada contribui√ß√£o, de qualquer colaborador, esteja alinhada com os princ√≠pios e a qualidade definidos no Manifesto Kubex.

> **Nosso lema:** Um comando para come√ßar. A filosofia do projeto para garantir a qualidade.

## üöÄ In√≠cio R√°pido

### Pr√©-requisitos

- Go 1.25+
- Make

### Instala√ß√£o

```bash
# Compila e instala o bin√°rio kbx no seu GOPATH/bin
make install
Configura√ß√£o
O kbx √© projetado para funcionar out-of-the-box em um reposit√≥rio Kubex. Ele procura automaticamente por uma pasta .kubex/ contendo os arquivos de configura√ß√£o e manifestos.

üõ†Ô∏è Uso B√°sico
Verifique se o ambiente est√° pronto:

Bash

kbx doctor
Inicie uma nova tarefa com um objetivo claro:

Bash

kbx objective "Refatorar o parser de configura√ß√£o para suportar a nova flag --strict"
Audite suas mudan√ßas atuais contra os princ√≠pios do projeto:

Bash

kbx audit
Prepare seu commit, garantindo a conformidade com os padr√µes:

Bash

kbx commit
/// docs/architecture/Resilience-by-Design.md ///
# Resilience by Design ‚Äî Kortex/Kubex (Outline)

> Descrever a arquitetura resiliente e o ‚Äúoffline-first com melhoria progressiva‚Äù.
> Documento curto e objetivo, focado em produto.

## 1. Princ√≠pios
- *Offline-first*, reconex√£o autom√°tica, *event broadcasting* interno
- UI com indicadores de conectividade e frescor
- Fallback seguro sem MCP, upgrades com WebSockets quando presente

## 2. Padr√£o de Estados
- `AppContext` global (Next.js/TS strict)
- Filas de eventos, handlers idempotentes
- Retentativas com *backoff* e circuit breakers

## 3. Integra√ß√£o MCP
- Conex√£o WebSocket com reconex√£o
- Logs e m√©tricas em tempo real
- Estrat√©gia de degrada√ß√£o graciosa

## 4. Build/Deploy
- Static export (`output: 'export'`) para GitHub Pages
- Imagens `unoptimized: true`, trailingSlash
- CI com lint/test/build e checagens de qualidade

## 5. Aceite
- Build est√°vel
- Sem *runtime errors* offline
- Realtime upgrades funcionando quando MCP dispon√≠vel
/// docs/brand/kubex_brand_visual_spec.v0.0.1.md ///
# Kubex Brand Visual Spec
A visual identity guide for all Kubex modules and projects. This document ensures consistent branding across repositories, banners, and promotional assets.

## üé® Color Palette
- **Base / Background**: Deep dark blue-black (`#0a0f14` ‚Üí `#10151b`), subtle grid/dots
- **Primary**: Ciano `#00f0ff`, Verde `#00e676`
- **Secondary**: Roxo `#7c4dff`, Lil√°s `#8e24aa`
- **Contrast/Text**: `#e0f7fa`

## üî§ Typography
- **Title**: futuristic sans (Orbitron/Exo2/Bank Gothic), uppercase + neon glow
- **Subtitle**: monospace (IBM Plex Mono/Source Code Pro), sutil

## üî∑ Elements
Hex√°gonos com outline neon, linhas de conex√£o finas, grid/circuitos, √≠cones minimalistas (Docker, Helm, chat, charts). Radial glow sutil atr√°s do t√≠tulo.

## üìê Composition
1) T√≠tulo central (neon)  
2) Subt√≠tulo curto abaixo  
3) √çcones perif√©ricos em hex√°gonos conectados  
4) Espa√ßo para ‚Äúrespirar‚Äù (sem polui√ß√£o visual)

## üß© Modular Abstraction
- Mesmo DNA visual; cor prim√°ria distinta por m√≥dulo (ex.: GHbex‚ÜíCiano, Kortex‚ÜíTeal, Logz‚ÜíGreen, GoBE‚ÜíPurple)
- √çcones relevantes por dom√≠nio
- Composi√ß√£o consistente

## ‚úÖ Checklist de uso
- [ ] Background dark + textura leve
- [ ] T√≠tulo central neon
- [ ] Subt√≠tulo monospace
- [ ] 2‚Äì3 √≠cones perif√©ricos
- [ ] Linhas finas conectando
- [ ] Cor prim√°ria do m√≥dulo
- [ ] Grid sutil ao fundo
/// docs/governance/KUBEX_MANIFESTO.md ///
# Kubex ‚Äî Manifesto de Co-Autoria (Agentes Cofundadores)

> **Princ√≠pio**: agentes n√£o ‚Äúentregam tarefas‚Äù, **entregam produto**. Nada de arquivos de relato de tarefa no repo.

## Diretrizes
1. **Objetivo verific√°vel**: cada change precisa de resultado observ√°vel (build/test/endpoint/UX).
2. **Sem task-reports**: bloquear `TASK_SUMMARY*.md`, `agent_report*.md` e afins.
3. **Documenta√ß√£o √∫til**: README/guia/ADRs curtos; nada de di√°rios de execu√ß√£o.
4. **Consist√™ncia Kubex**: seguir Brand Visual + Craftsmanship Standards (Go/TS).
5. **Qualidade**: testes, lint, security checks.

## ‚ÄúDone‚Äù
- ‚úÖ Build ok, sem warnings cr√≠ticos
- ‚úÖ Testes cobrindo paths felizes/erro
- ‚úÖ Docs de uso atualizados quando aplic√°vel
- ‚úÖ Nenhum relat√≥rio de tarefa inserido
/// docs/module-spec.md ///
# Module Specification

```go
// Module is an interface that defines the methods a module must implement.
type Module interface {
  Alias() string
  ShortDescription() string
  LongDescription() string
  Usage() string
  Examples() []string
  Active() bool
  Module() string
  Execute() error
  Command() *cobra.Command
  SetParentCmdName(rtCmd string)
  concatenateExamples() string
}
```

```go
// Simple Generic Module Concrete Case
type ModuleConcrete struct {
 parentCmdName string
 printBanner   bool
}

/*
  Abaixo est√£o os m√©todos que representam wrappers
  de dados b√°sicos do m√≥dulo, enquanto CLI e Lib.

  Esses m√©todos s√£o obrigat√≥rios para qualquer m√≥dulo.
 */
func (m *ModuleConcrete) Alias() string {
 return "module"
}
func (m *ModuleConcrete) ShortDescription() string {
 return "ModuleConcrete short description."
}
func (m *ModuleConcrete) LongDescription() string {
 return `ModuleConcrete long description.`
}
func (m *ModuleConcrete) Usage() string {
 return "module [command] [args]"
}
func (m *ModuleConcrete) Examples() []string {
 return []string{
  "module doctor <subcommand>",
  "module platform <subcommand>",
 }
}
func (m *ModuleConcrete) Active() bool {
 return true
}
func (m *ModuleConcrete) Module() string {
 return "module"
}
func (m *ModuleConcrete) Execute() error {
 return m.Command().Execute()
}

func (m *ModuleConcrete) Command() *cobra.Command {
/*
  Todo m√≥dulo, pode opcionalmente usar o `Annotations`
  como uma camada de metadados para o comando.
  Ele cont√©m dois argumentos:
    - Descriptions: []string{}
      Ele ir√° lidar com os Short e Long descriptions
      contemplando a abstra√ß√£o que h√° trazendo estiliza√ß√£o
      e formata√ß√£o.

    - hideBanner: bool
      Se verdadeiro, oculta a exibi√ß√£o do banner do m√≥dulo e
      torna o comportamento do Cobra em rela√ß√£o ao Short e Long
      descriptions nativo novamente.
 */

 rootCmd := &cobra.Command{
  Use:   m.Module(),
  Alias: m.Alias(),
  Short: m.ShortDescription(),
  Long:  m.LongDescription(),
  // Aqui h√° um tratamento quebrando as linhas do
  // array de exemplos na exibi√ß√£o. Permitindo
  // que seja ve√≠culado v√°rios exemplos para o mesmo comando
  // de forma organizada.
  Example: m.concatenateExamples(),

  Annotations: m.GetDescriptions(
    []string{
      m.ShortDescription(),
      m.LongDescription(),
    }, m.printBanner,
  ),
  RunE: func(cmd *cobra.Command, args []string) error {
   return m.Execute()
  },
 }

// Aqui voc√™ pode adicionar subcomandos ao comando raiz
// Ex: rootCmd.AddCommand(subCmd1, subCmd2)

// Ap√≥s inserir os comandos, √© necess√°rio acionar o
// registro do template e cores para o Cobra.
// Isso faz com que o CLI tenha uma apar√™ncia
// mais amig√°vel e estilizada, al√©m de padronizada
// para todos os m√≥dulos do ecossistema.
 setUsageDefinition(rtCmd)

 // Esse loop existe para garantir que os padr√µes de
 // estilo tamb√©m sejam aplicados aos subcomandos.
 for _, c := range rtCmd.Commands() {
  setUsageDefinition(c)
  if !strings.Contains(strings.Join(os.Args, " "), c.Use) {
   if c.Short == "" {
    c.Short = c.Annotations["description"]
   }
  }
 }

// Retorna o comando completo.
 return rootCmd
}
```
